<!DOCTYPE html SYSTEM "about:legacy-compat">
<html >
      <head>
        <title>GeoTrellis — Combined Pages</title>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/blueprint/screen.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/blueprint/grid.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/blueprint/print.css"></link> 
        <!--[if lt IE 8]>
          <link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection"/>
        <![endif]-->
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/pamflet.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/pamflet-print.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/pamflet-grid.css"></link>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/custom.css"></link>
        <script src="js/jquery-1.6.2.min.js"></script>
        <script src="js/jquery.collapse.js"></script>
        <script src="js/pamflet.js"></script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"></link><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <meta charset="utf-8"></meta>
        <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      </head>
      <body>
        <a class="page prev nav" href="Contents+in+Depth.html">
            <span class="space">&nbsp;</span>
            <span class="flip">&gt;</span>
          </a>
        <div class="container">
          <div class="span-16 prepend-1 append-1">
            <div class="top nav span-16 title">
              <span>GeoTrellis</span> — Combined Pages
            </div>
          </div>
          <div class="span-16 prepend-1 append-1 contents">
            <div class="tocwrapper show">
      <a class="tochead nav" style="display: none" href="#toc">❦</a>
      <a name="toc"></a>
      <h4 class="toctitle">Contents</h4>
      <div class="tocbody">
      <div><a href="#GeoTrellis">GeoTrellis</a></div><ol class="toc"> <li><div><a href="#API+Reference">API Reference</a></div></li><li><div><a href="#Get+started+with+the+template+project">Get started with the template project</a></div></li><li><div><a href="#Web+Service+Tutorial">Web Service Tutorial</a></div></li><li><div><a href="#Setting+up+GeoTrellis">Setting up GeoTrellis</a></div></li><li><div><a href="#Operations">Operations</a></div></li><li><div><a href="#Creating+new+operations">Creating new operations</a></div></li><li><div><a href="#Parallel+and+distributed+execution">Parallel and distributed execution</a></div></li> </ol></div></div><h1 id="GeoTrellis">GeoTrellis</h1><p><em>GeoTrellis</em> is a high performance geoprocessing engine and programming
toolkit. The goal of the project is to transform user interaction with
geospatial data by bringing the power of geospatial analysis to real time,
interactive web applications.
</p><p>GeoTrellis was designed to solve three core problems, with a focus on raster
processing:
</p><ul><li>Creating scalable, high performance geoprocessing web services
</li><li>Creating distributed geoprocessing services that can act on large data sets
</li><li>Parallelizing geoprocessing operations to take full advantage of multi-core
architecture 
</li></ul><p>GeoTrellis is a project of Azavea (www.azavea.com), and was written by Josh
Marcus (jmarcus@azavea.com) and Erik Osheim (eosheim@azavea.com). Please
contact us if you have any questions!
</p><h2 id="Features">Features</h2><ul><li>GeoTrellis is designed to help a developer create simple, standard REST
services that return the results of geoprocessing models.
</li><li>Like an RDBS that can optimize queries, GeoTrellis will automatically
parallelize and optimize your geoprocessing models where possible.  
</li><li>In the spirit of the object-functional style of Scala, it is easy to both
create new operations and compose new operations with existing operations.
</li></ul><h2 id="Some+sample+GeoTrellis+code">Some sample GeoTrellis code</h2><pre><code class="prettyprint lang-scala">  // import the necessary stuff
  import geotrellis._
  import geotrellis.op.io
  import geotrellis.op.raster.local

  // set up the rasters and weights we'll use
  val raster1 = io.LoadRaster(&quot;foo&quot;)
  val raster2 = io.LoadRaster(&quot;bar&quot;)
  val weight1 = 5
  val weight2 = 2

  val total = weight1 + weight2

  // create a new operation that multiplies each cell of
  // each raster by a weight, and then add those two new
  // rasters together.
  val op = local.Add(local.MultiplyConstant(raster1, weight1),
                     local.MultiplyConstant(raster2, weight2))

  // create a new operation that takes the result of the
  // previous operation and divides each cell by the total
  // weight, creating a weighted overlay of our two rasters.
  val wo1 = local.DivideConstant(op, total)

  // we can use a simpler syntax if we want. note that this
  // is still just creating an operation.
  import geotrellis.Implicits._
  val wo2 = (raster1 * weight1 + raster2 * weight2) / total

  // to this point, we've only been composing new operations.
  // now we will run them.
  import geotrellis.process.Server
  val server = Server(&quot;example&quot;)
  val result1 = server.run(wo1)
  val result2 = server.run(wo2)
</code></pre><h2 id="API+Reference">API Reference</h2><h3 id="Scaladocs">Scaladocs</h3><p>You can find <em>Scaladocs</em> for the latest version of the project <a  href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.package">here</a>.
</p><h3 id="Operations">Operations</h3><p>A full list of core operations can be in found in the <a  href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.package">Scala API documentation</a> for the <code>geotrellis.op</code> package.
</p><h3 id="Template+project">Template project</h3><p>We have created a <a  href="https://github.com/azavea/geotrellis-template">template project</a>
that you can use as a launching pad for new REST services based on GeoTrellis.
It is a simple project that uses SBT to load the GeoTrellis dependencies and
has the basic infrastructure in place to help you get started quickly.
</p><h2 id="Get+started+with+the+template+project">Get started with the template project</h2><p>We have provided a sample project that provides a template for creating a 
geoprocessing web service with GeoTrellis. It is a blank slate for your own
development that provides a development environment that is set up with the
necessary dependencies in place, making it a little easier to get started.
</p><p>The project loads GeoTrellis as a library, includes some basic configuration,
and has a very simple “hello world” web service in place for you to edit.
The template contains <a  href="https://github.com/azavea/geotrellis-template">step-by-step instructions</a>.
</p><p>If you are a first time GeoTrellis user, you can use this template with the
tutorial included in this documentation to start exploring how to build your
own geoprocessing service.
</p><h2 id="Web+Service+Tutorial">Web Service Tutorial</h2><p>GeoTrellis is commonly used to build web services.
</p><p>Here we will show you how to build simple web services with Jetty that uses
GeoTrellis.
</p><h3 id="Hello+World">Hello World</h3><p>This is the most basic web service—in fact, it doesn’t directly use GeoTrellis
at all. However, it contains all the imports and objects that the other
examples will need, as well as providing an example of writing a Jetty web
service in Scala.
</p><p>This service can be accessed at <code>http://localhost:8000/greeting</code> and should
print “hello world”. You may want to substitude your own values for <code>mypackage</code>
and <code>MyApp</code>.
</p><pre><code class="prettyprint lang-scala">package mypackage

import javax.servlet.http.HttpServletRequest
import javax.ws.rs.{GET, Path, DefaultValue, PathParam, QueryParam}
import javax.ws.rs.core.{Response, Context}

import geotrellis._
import geotrellis.op._
import geotrellis.process._

object MyApp {
  val server = Server(&quot;myapp&quot;, &quot;src/main/resources/myapp-catalog.json&quot;)
  def response(mime:String)(data:Any) = Response.ok(data).`type`(mime).build()
}

@Path(&quot;/greeting&quot;)
class HelloWorld {
  @GET
  def get(@Context req:HttpServletRequest) = {
    // give a friendly greeting
    MyApp.response(&quot;text/plain&quot;)(&quot;hello world&quot;)
  }
}
</code></pre><h3 id="Adder">Adder</h3><p>With that out of the way, here’s a REST service that actually does something:
it treats the final part of the URL as a number, adds one to it, and returns
that number as plaintext. For instance, <code>http://localhost:8080/adder/127</code> would
return “128”.
</p><p>The important thing to see here is that <code>ParseInt</code> doesn’t actually do any
work. It creates an operation which when run will parse an input <code>String</code> and
return an <code>Int</code>. But running operations isn’t the only thing you can do. In our
case, <code>opX + 1</code> actually builds us a new operation, which evaluates <code>opX</code> and
then adds one to it. If there is an exception (i.e. the parameter is not a
valid number) it will only occur when <code>MyApp.server.run</code> is called.
</p><p>This means that instead of sprinkling error-handling code through your handler,
you only need to guard your calls to <code>server.run</code>. Combining operations allows
the web service author to focus on correctly encoding application logic without
having to handle errors at every possible point.
</p><p>Calling <code>server.run</code> returns an integer value which can be passed to the user.
</p><pre><code class="prettyprint lang-scala">import geotrellis.op.util.string.ParseInt
import geotrellis.Implicits._

@Path(&quot;/adder/&quot;)
class AddOne {
  @GET
  @Path(&quot;/{x}&quot;)
  def get(@PathParam(&quot;x&quot;) s:String,
          @Context req:HttpServletRequest) = {
    // parse the given integer
    val opX:Op[Int] = ParseInt(s)

    // add one
    val opY:Op[Int] = opX + 1

    // run the operation
    val data:String = try {
      val y:Int = MyApp.server.run(opY)
      y.toString
    } catch {
      case e =&gt; e.toString
    }

    MyApp.response(&quot;text/plain&quot;)(data)
  }
}
</code></pre><h3 id="Bounding+Box+Union">Bounding Box Union</h3><p>This example is similar to the previous one, but a bit more complicated: it
uses <code>geotrellis.Extent</code>, an object which represents a geographical bounding box.
The service uses two extents, each encoded in a string as
<code>xmin,ymin,xmax,ymax</code>. For example, using the Web Mercator coordinate system a
bounding box around Philadelphia might be encoded as:
</p><p><code>-8475497.88486,4825540.69147,-8317922.88486,4954765.69147</code>
</p><p>This service takes two such extents and combines them, returning the smallest
extent that contains both of them. For instance, the request:
</p><p><code>http://localhost:8000/bbox/0,0,10,10/union/5,-10,15,0</code>
</p><p>will result in <code>0,-10,15,10</code>.
</p><pre><code class="prettyprint lang-scala">import geotrellis.op.raster.extent

@Path(&quot;/bbox/&quot;)
class BoundingBox {
  @GET
  @Path(&quot;/{extent1}/union/{extent2}&quot;)
  def get(@PathParam(&quot;extent1&quot;) s1:String,
          @PathParam(&quot;extent2&quot;) s2:String,
          @Context req:HttpServletRequest) = {
    // parse the given extents
    val e1:Op[Extent] = extent.ParseExtent(s1)
    val e2:Op[Extent] = extent.ParseExtent(s2)

    // combine the extents
    val op:Op[Extent] = extent.CombineExtents(e1, e2)

    // run the operation
    val data = try {
      val extent:Extent = MyApp.server.run(op)
      extent.toString
    } catch {
      case e =&gt; e.toString
    }

    MyApp.response(&quot;text/plain&quot;)(data)
  }
}
</code></pre><h3 id="Draw+Raster">Draw Raster</h3><p>Finally, we will actually do some raster processing! This example shows how to
load raster data, create a palette of colors, assign those colors to value
rangers (classes) in the raster, and create a PNG to send to the user. Whenever
you are rendering an image for a user, you will probably need to go through
these same steps (although you may choose to hardcode the colors). 
</p><p>Given a <code>name</code>, the <code>LoadRaster</code> operation will return a <code>geotrellis.IntRaster</code>
instance containing the appropriate raster data. This class represents a file
of raster data in the <code>arg32</code> format. If you have raster data in another format
(e.g. <code>.tif</code> or <code>.asc</code>) it will need to be converted ahead of time.
</p><p>The <code>palette</code> and <code>shades</code> arguments are used to construct the color palette to
use. For example:
</p><p><code>http://localhost:8000/draw/foo/palette/ff0000,0000ff/shades/3</code>
</p><p>specifies that the palette should be a gradient from red (<code>ff0000</code>) to blue
(<code>0000ff</code>) containing 5 colors. The colors chosen in this case would be:
</p><ul><li>red (<code>ff0000</code>)
</li><li>reddish-purple (<code>bf003f</code>)
</li><li>purple (<code>7f007f</code>)
</li><li>bluish-purple (<code>3f00bf</code>)
</li><li>blue (<code>0000ff</code>)
</li></ul><p>The rest of the code builds a <code>geotrellis.stat.Histogram</code> object (using
<code>BuildMapHistogram</code>) to determine what value ranges should map to which colors
(using <code>GetColorsBreaks</code> to create a <code>geotrellis.data.ColorBreaks</code>). A full
explanation of the methodology is beyond the scope of this tutorial, but the
basic idea is to try to find ranges of equal size in the raster, so that the 5
colors are evenly used. Thus, assuming our values ranged from 0-100, we might
create the following ranges (also know as “breaks”): 
</p><ul><li>0-12: red
</li><li>13-30: reddish-purple
</li><li>31-36: purple
</li><li>37-60: bluish-purple
</li><li>61-100: blue
</li></ul><p>Finally, we render the PNG using the raster and color breaks we found.
</p><p>Again, remember that none of this work is happening until after the “run the
operation” comment. This means that any errors (e.g. invalid colors, invalid
raster, other problems) won’t happen until that point. It also means that we
could as many raster transformations as we want without needing to modify any
of the rendering code, or the error-handling.   
<br/>
One thing to note is that this code is not doing any kind of resampling or
resizing. In your own code, you will usually want to load raster data for a
particular extent (e.g. a tile) at a particular resolution (e.g. 256x256). This
services loads and renders the entire raster at its underlying resolution,
which can be slower.
</p><pre><code class="prettyprint lang-scala">import geotrellis.op.util.string.{SplitOnComma,ParseInt}

@Path(&quot;/draw/&quot;)
class DrawRaster {
  @GET
  @Path(&quot;/{name}/palette/{palette}/shades/{shades}&quot;)
  def get(@PathParam(&quot;name&quot;) name:String,
          @PathParam(&quot;palette&quot;) palette:String,
          @PathParam(&quot;shades&quot;) shades:String,
          @Context req:HttpServletRequest) = {

    // load the raster
    val rasterOp = raster.data.LoadRaster(name)

    // find the colors to use
    val paletteOp = logic.ForEach(SplitOnComma(palette))(ParseInt(_,16))
    val numOp = ParseInt(shades)
    val colorsOp = raster.stat.GetColorsFromPalette(paletteOp, numOp)

    // find the appropriate quantile class breaks to use
    val histogramOp = raster.stat.Histogram(rasterOp)
    val breaksOp = raster.stat.GetColorBreaks(histogramOp, colorsOp)

    // render the png
    val pngOp = raster.data.RenderPNG(rasterOp, breaksOp, 0, true)

    // run the operation
    try {
      val img:Array[Byte] = MyApp.server.run(pngOp)
      MyApp.response(&quot;image/png&quot;)(img)
    } catch {
      case e =&gt; MyApp.response(&quot;text/plain&quot;)(e.toString)
    }
  }
}
</code></pre><h3 id="Conclusion">Conclusion</h3><p>These services are all toys, but together they illustrate some of the concepts
used by GeoTrellis. For a more complete example please see
<code>geotrellis.rest.Demo</code> in the <code>demo</code> project which implements a more complete
weighted overlay service.
</p><h2 id="Setting+up+GeoTrellis">Setting up GeoTrellis</h2><h3 id="Configuration">Configuration</h3><p>GeoTrellis has two important configuration files:
</p><ol><li>application.conf: defines most system parameters.
</li><li>catalog.json: defines what geospatial data is available.
</li></ol><h4 id="Application+configuration">Application configuration</h4><p>The main application configuration defines important system parameters used by
your application. Some are required by GeoTrellis, while a particular
application might introduce others.
</p><p>The configuration file should be on the classpath of your application. When
using SBT, the file is often located at <code>src/main/resources/application.conf</code>.
</p><p>You can also override individual configuration parameters with Java system
properties, e.g. <code>java -Dgeotrellis.port=5555 ...</code>
</p><p>Example:
</p><pre><code class="">geotrellis.host = &quot;0.0.0.0&quot;            // server address to listen on
geotrellis.port = 8888                 // server port to listen on
geotrellis.rest-package = &quot;myapp.rest&quot; // package to search for REST services
geotrellis.tmp = &quot;/tmp&quot;                // location for temporary files
</code></pre><h4 id="Data+catalog">Data catalog</h4><p>The data catalogs is a JSON file containing information about the data
available to GeoTrellis. The catalog is made up of data stores from which data
can be loaded, and also can contain additional information about individual
layers. 
</p><p>For example, the following <code>catalog.json</code> file defines a data directory from
which any .arg files with accompanying .json metadata will be loaded.
</p><pre><code class="prettyprint lang-json">{
 &quot;catalog&quot;: &quot;my-catalog&quot;,
 &quot;stores&quot;: [
  {
   &quot;store&quot;: &quot;data:fs&quot;,
   &quot;params&quot;: {
     &quot;type&quot;: &quot;fs&quot;,
     &quot;path&quot;: &quot;/var/myapp/data&quot;
   }
  }
 ]
}
</code></pre><h3 id="Importing+Raster+Data">Importing Raster Data</h3><p>GeoTrellis uses a custom raster format, ARG (Azavea Raster Grid), to encode
raster data. This format is maximally simple to read and write, and is designed
for efficient random access.
</p><p>The most recent development version of GDAL (http://www.gdal.org/) can convert
files from most raster formats into the ARG format. This is by far the best way
to convert data to the ARG format that GeoTrellis uses for raster data.
</p><p>Please feel free to ask for advice on the mailing list on installing a recent
version of GDAL. There is also an AMI Ubuntu instance for EC2 with GeoTrellis
and a recent version of GDAL installed.  
</p><h2 id="Operations">Operations</h2><p>This wll be a reference table of operations you can use in your services, but it 
has not yet been updated for 0.7.
</p><!--
<table class="bordered-table zebra-striped">
      <thead>
          <tr>
            <th>Operation</th>
            <th>Output</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.Add">Add</a></code></td><td>Raster</td><td>Add the values of each cell in each raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.AddArray">AddArray</a></code></td><td>Raster</td><td>Add the values of each cell in each raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.AddConstant">AddConstant</a></code></td><td>Raster</td><td>Add a constant value to each cell.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.AutomaticNormalize">AutomaticNormalize</a></code></td><td>Raster</td><td>Normalize the values in the given raster so that all values are within the ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.BinaryDoCell">BinaryDoCell</a></code></td><td>Raster</td><td>Perform a function on every cell in a raster with the values from another raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.BinaryIfCell">BinaryIfCell</a></code></td><td>Raster</td><td>Given a condition over two rasters, set the value of each cell in the output ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.BinaryIfElseCell">BinaryIfElseCell</a></code></td><td>Raster</td><td>Given a condition over two rasters, set the value of each cell in the output ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.BinaryLocal">BinaryLocal</a></code></td><td>Raster</td><td>BinaryLocal is an abstract class for all operations that are both local (operating ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.Bitmask">Bitmask</a></code></td><td>Raster</td><td>Bitmask each cell by a constant value.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.BuildArrayHistogram">BuildArrayHistogram</a></code></td><td>Histogram</td><td>Build an array histogram (see <a name="geotrellis.stat.ArrayHistogram" class="extype" href="../stat/ArrayHistogram.html">ArrayHistogram</a> of values from ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.BuildCompressedArrayHistogram">BuildCompressedArrayHistogram</a></code></td><td>Histogram</td><td>Build a histogram (using the <a name="geotrellis.stat.CompressedArrayHistogram" class="extype" href="../stat/CompressedArrayHistogram.html">CompressedArrayHistogram</a> ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.BuildHistogram">BuildHistogram</a></code></td><td>Histogram</td><td>Generic trait used by the various histogram-building operations.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.BuildMapHistogram">BuildMapHistogram</a></code></td><td>Histogram</td><td>Build a histogram (using the <a name="geotrellis.stat.MapHistogram" class="extype" href="../stat/MapHistogram.html">MapHistogram</a> strategy) from ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.BuildRasterExtent">BuildRasterExtent</a></code></td><td>RasterExtent</td><td>Given a geographical extent and grid height/width, return an object used to ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.BurnPolygon">BurnPolygon</a></code></td><td>Raster</td><td>Rasterize a polygon and then draw it on the provided raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.BurnPolygons">BurnPolygons</a></code></td><td>Polygon</td><td>Rasterize an array of polygons and then draw them into the provided raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.BurnPolygonsWithTransform">BurnPolygonsWithTransform</a></code></td><td>Raster</td><td>Rasterize an array of polygons and then draw them into the provided raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.BurnPolygonsWithValue">BurnPolygonsWithValue</a></code></td><td>Polygon</td><td>Rasterize an array of polygons and then draw them into the provided raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.CachedOp">CachedOp</a></code></td><td>T</td><td>Trait providing caching support for operations which want to save their ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.ChunkRasterExtent">ChunkRasterExtent</a></code></td><td>RasterExtent</td><td>Used to chunk a RasterExtent object (geographical extent + grid information) ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.CopyRaster">CopyRaster</a></code></td><td>Raster</td><td>Given an operation producing a raster, returns a copy of this raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.CreateRaster">CreateRaster</a></code></td><td>Raster</td><td>Creates an empty raster object based on the given raster properties.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.CreateSimplePolygon">CreateSimplePolygon</a></code></td><td>Double)</td><td>Create a Polygon from an array of coordinates represented as a tuple (x,y).</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.CropRasterExtent">CropRasterExtent</a></code></td><td>RasterExtent</td><td>Given a geographical extent and grid height/width, return an object used to ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.CropRasterExtentByExtent">CropRasterExtentByExtent</a></code></td><td>RasterExtent</td><td>Given a geographical extent and grid height/width, return an object used to ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.CsvIntMap">CsvIntMap</a></code></td><td>Int</td><td>Create a Map of (String,String) =&gt; Int from a CSV file ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.Divide">Divide</a></code></td><td>Raster</td><td>Divide each value of one raster with the values from another raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.DivideConstant">DivideConstant</a></code></td><td>Raster</td><td>Divide each cell by a constant value.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.DivideConstantBy">DivideConstantBy</a></code></td><td>Raster</td><td>For each cell, divide a constant value by that cell's value.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.DoCell">DoCell</a></code></td><td>Raster</td><td>Perform a function on every cell in a raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.FindClassBreaks">FindClassBreaks</a></code></td><td>Int</td><td>Generate quantile class breaks for a given raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.FindColorBreaks">FindColorBreaks</a></code></td><td>ColorBreaks</td><td>Generate quantile class breaks with assigned colors.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.FindMinMax">FindMinMax</a></code></td><td>(Int,Int)</td><td>Find the minimum and maximum value of a raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.ForEach">ForEach</a></code></td><td>Z</td><td>Evaluates then given operation (op) to get an array of A's.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.ForEach2">ForEach2</a></code></td><td>Z</td><td>Evaluates then given operations (opA and opB) to get an array of A's and an ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.ForEach3">ForEach3</a></code></td><td>Z</td><td>Evaluates then given operations (opA opB, and opC) to get arrays of A's, B's ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.ForEachTile">ForEachTile</a></code></td><td>Raster</td><td>Perform an operation on every tile in a tileset, and return the new tileset.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.GenerateStatistics">GenerateStatistics</a></code></td><td>Statistics</td><td>Determine statistical data for the given histogram.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.GetPolygonExtent">GetPolygonExtent</a></code></td><td>Extent</td><td>Return the extent of a given polygon.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.GetRasterExtent">GetRasterExtent</a></code></td><td>RasterExtent</td><td>Get the geotrellis.geoattrs.RasterExtent from a given raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.Hillshade">Hillshade</a></code></td><td>Raster</td><td>Hillshade creates a raster that, visually, adds a three dimensional appearance to an elevation raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.Identity">Identity</a></code></td><td>Raster</td><td>Suspiciously similar to <a name="geotrellis.op.CopyRaster" class="extype" href="CopyRaster.html">CopyRaster</a>, Identity returns ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.IfCell">IfCell</a></code></td><td>Raster</td><td>Maps all cells matching <code>cond</code> to <code>trueValue</code>.</p> ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.IfElseCell">IfElseCell</a></code></td><td>Raster</td><td>Set all values of output raster to one value or another based on whether a ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.InverseMask">InverseMask</a></code></td><td>Raster</td><td>Generate a raster with the values from the first raster, but only include ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.KernelDensity">KernelDensity</a></code></td><td>Raster</td><td>Compute the kernel density of a set of points onto a raster</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.Literal">Literal</a></code></td><td>A</td><td>Return the literal value specified.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.LoadFile">LoadFile</a></code></td><td>Raster</td><td>Load the raster data for a particular extent/resolution from the specified file.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.LoadRaster">LoadRaster</a></code></td><td>Raster</td><td>Load the raster data for a particular extent/resolution from the specified file.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.LoadRasterExtentFromFile">LoadRasterExtentFromFile</a></code></td><td>RasterExtent</td><td>Load the geotrellis.geoattrs.RasterExtent from the raster in the specified file.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.LocalOperation">LocalOperation</a></code></td><td>Raster</td><td>Local operations involve each individual value in a raster without information ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.Map1">Map1</a></code></td><td>Z</td><td>Map an Op[A] into an Op[Z] using a function from A =&gt; Z.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.Map2">Map2</a></code></td><td>Z</td><td>Map an Op[A] and Op[B] into an Op[Z] using a function from (A,B) =&gt; Z.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.Mask">Mask</a></code></td><td>Raster</td><td>Generate a raster with the values from the first raster, but only include ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.MaxConstant">MaxConstant</a></code></td><td>Raster</td><td>Set each cell to a constant number or the corresponding cell value, whichever is highest.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.MinConstant">MinConstant</a></code></td><td>Raster</td><td>Set each cell to a constant or its existing value, whichever is lowest.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.Multiply">Multiply</a></code></td><td>Raster</td><td>Multiply each cell of each raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.MultiplyArray">MultiplyArray</a></code></td><td>Raster</td><td>Multiply each cell of each raster in array.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.MultiplyConstant">MultiplyConstant</a></code></td><td>Raster</td><td>Multiply each cell by a constant.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.Negate">Negate</a></code></td><td>Raster</td><td>Negate (multiply by -1) each value in a raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.Operation">Operation</a></code></td><td>T</td><td>Base Operation for all GeoTrellis functionality.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.PolygonExtent">PolygonExtent</a></code></td><td>Polygon</td><td>Return the extent of a given polygon.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.PolygonalZonalHistograms">PolygonalZonalHistograms</a></code></td><td>Histogram</td><td>Given a raster and an array of polygons, return a histogram summary of the cells ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.PowConstant">PowConstant</a></code></td><td>Raster</td><td>Raise each cell to the cth power.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.PrecomputedNormalize">PrecomputedNormalize</a></code></td><td>Raster</td><td>Normalize the values in the given raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.RenderPNG">RenderPNG</a></code></td><td>Byte</td><td>Generate a PNG from a given raster and a set of color breaks.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.ResampleRaster">ResampleRaster</a></code></td><td>Raster</td><td>This uses a nearest-neighbor algorithm to resample a raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.SplitMultiPolygon">SplitMultiPolygon</a></code></td><td>Polygon</td><td>Split multipolygon into polygons.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.StandardDeviation">StandardDeviation</a></code></td><td>Raster</td><td>Calculate the standard deviation of each cell from the values in the raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.Subtract">Subtract</a></code></td><td>Raster</td><td>Subtract each value in the second raster from the corresponding value in the first raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.SubtractConstant">SubtractConstant</a></code></td><td>Raster</td><td>Subtract a constant value from each cell.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.SubtractConstantBy">SubtractConstantBy</a></code></td><td>Raster</td><td>Subtract the value of each cell by a constant.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.UnaryLocal">UnaryLocal</a></code></td><td>Raster</td><td>Abstract class for all operations that are unary (operate on a single raster) and ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.WarpRaster">WarpRaster</a></code></td><td>Raster</td><td>Crop a raster to a given extent, using a nearest neighbor algorithm to resample.</td></tr>
<tr><td><code><a href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.op.ZonalHistogram">ZonalHistogram</a></code></td><td>Histogram</td><td>Given a raster, return a histogram summary of the cells within each zone.</td></tr>
        </tbody>
      </table>
-->
<h2 id="Creating+new+operations">Creating new operations</h2><p>Ideally, a new geoprocessing service can be composed with existing operations
that have already been created for you.  The tutorial, for example, shows a
series of examples of a service being created by composing existing operations.
</p><p>But sometimes it is necessary to create new operations instead of simply
composing a new process with existing operations. There is a short method and
the full method creating new operations.
</p><p>When thinking about operations, think about them like a mathematical function—
operations take input and produce an output.  The inputs to all operations are 
operations themselves.  You can think about this as a data pipeline, in which
each operation’s output is connected to the input of its parent operations.
</p><h3 id="Short+method">Short method</h3><p>Let’s create a simple operation that adds two integers together.
</p><p>We’ll make an operation that can be instantiated with the following code:
</p><pre><code class="prettyprint lang-scala">val a = AddInts(1, 2)
val result = server.run(a)
</code></pre><p>This is an example of using the short method to define an operation:
</p><pre><code class="prettyprint lang-scala">case class AddInts(a:Op[Int], b:Op[Int]) extends Op2(a, b) ({
  (a, b) =&gt; {
    a + b
  }
})
</code></pre><p>The operation above is called <code>AddInts</code>.  <code>Op</code> is short for Operation.
Right after AddInts are the inputs to this operation, called <code>a</code> and <code>b</code>.
The declaration <code>a:Op[Int]</code> means that the first input is of the type <code>Op[Int]</code>.
<code>[Int]</code> is the type parameter of <code>Op</code>, and it means that a is an operation
that outputs an Int (an integer). The class <code>AddInts</code> exends the class
<code>Op2</code>, which means that it is an operation that takes two inputs. If this
operation had only 1 input, we’d use <code>Op1</code> instead of <code>Op2</code>. 
</p><p>For example:
</p><pre><code class="prettyprint lang-scala">case class AddOne(a:Op[Int]) extends Op1(a) ({
  (a) =&gt; {
    a + 1
  }
})
</code></pre><p>The syntax in the middle, e.g.:
</p><pre><code class="prettyprint lang-scala">  (a,b) =&gt; {
    a + b
  }
</code></pre><p>means that we are making a function that takes two arguments (a and b) and we
define the body of the function that does the actual work with the inputs
between the two braces.
</p><p>You can see lots of examples of Operations in <code>src/main/geotrellis/op</code>.
</p><h3 id="Full+method">Full method</h3><p>Instead of the short syntax (in which operations extend <code>Op1</code>..<code>OpN</code>) you can
create a class which extends <code>Op[T]</code>. This approach exposes the underlying
methods that operations use to load data (via the <code>Context</code> object) and also to
stage calculations across multipe steps.
</p><pre><code class="prettyprint lang-scala">case class Add(a:Op[Int], b:Op[Int]) extends Op[Int] {
  def _run(context:Context) = {
    runAsync(List(a, b))
  }
  def nextSteps:Steps = {
    case (a:Int) :: (b:Int) :: Nil =&gt; {
      a + b
    }
  }
}
</code></pre><p>The _run method is where the execution of the operation begins. We call
<code>runAsync</code> with a list of operations to tell the server to asynchronous execute
our child operations, and then the partial function <code>nextSteps</code> is executed
when all of the results have been retrieved.
</p><p>If we need to pass any information forward, we can include it in the List given
to <code>runAsync</code> All operations passed to <code>runAsync</code> will be executed (in
parallel), while other values will simply be passed through. The resulting list
will be matched against <code>nextSteps</code>, which will continue executing the
calculation. The syntax used in <code>nextSteps</code> (involving one of more <code>case</code>
statements) is the same as other pattern matching in Scala.
</p><p>For example, the following code tries to find the pattern of a two-element list
where the first element and second elements are integers. If the input matches
this pattern, it saves the first element in <code>a</code> and the second in <code>b</code> and
executes the provide block of code.
</p><p>If you want to understand more about the machinery at work here, see the
<em>Architecture Concepts</em> section and the Server code
(<code>geotrellis/process/server.scala</code> and <code>geotrellis/process/actors.scala</code>).
</p><h2 id="Parallel+and+distributed+execution">Parallel and distributed execution</h2><h3 id="Parallel+Execution">Parallel Execution</h3><p>Most operations have “child operations” which are the inputs or incoming data
streams that the operation acts on. GeoTrellis will automatically run all child
operations in parallel. For example, if you are adding each cell of five
rasters together, the service will calculate each input raster in parallel (if
resources allow).
</p><p>If working with a single large data set (e.g. a large raster), it is usually
beneficial to transform the raster into a tiled raster which allows the system
to parallelize the work and to reduce I/O.
</p><h3 id="Distributed+Execution">Distributed Execution</h3><p>With a single command, an operation can be transformed into a RemoteOperation
that sends each of its child operations to a remote GeoTrellis server for
execution.
</p><pre><code class="prettyprint lang-scala">// calculate each input raster on remote cluster
local.Add(r1,r2,r3).remote(cluster)
</code></pre><p>The remote cluster or server is an Akka actor or load balancer, defined using
the Akka library configuration. See the <a  href="http://akka.io/docs/akka/2.0-M4">Akka documenation</a>
for more information. Akka configuration can be placed directly in your
GeoTrellis configuration file (application.conf).
</p><p>For operations that do not need to pass much data over the network, the
overhead can be as low as a few milliseconds. When passing raster data, the
time overhead depends on the network and the size of the rasters. 
</p><h3 id="Architecture+Concepts">Architecture Concepts</h3><p>Behind the scenes, GeoTrellis is using the actor model for parallel and
distributed computation—the primary abstraction is message passing instead of
shared memory. This event-based model allows us to re-use the same threads by
interleaving calculations for different processes on the same threads, but
requires operations to be asynchronous. Operations are not allowed to block
while waiting on another result because that would hold up the other work that
is scheduled to execute on the same thread. 
</p><p>By using the <a  href="http://en.wikipedia.org/wiki/Continuation-passing_style">continuation passing style</a>
from functional programming we perform work in a series of stages:
</p><ol><li>Calculation begins on a particular thread.
</li></ol><p> 2a. If calculation can complete, it does so (and we are done).
 2b. Otherwise, the calculation and its subsidiaries are sent to a dispatcher.
 3. Calculation exits, freeing the thread.
 4. Subsidiary calculations are sent to new threads to be processed.
 5. When all subsidiary results are available, the next calculation step begins on a new thread.
</p><p>Thus, we can perform complex calculations across many threads, without ever
blocking execution on an individual thread.
</p><p>Operations are sent as immutable messages, and are referrentially transparent.
This allows us to perform optimizations such as combining  
<br/>
local raster operations. 
</p>
          </div>
        </div>
        <a class="fork nav" href="http://github.com/azavea/geotrellis"><img alt="Fork me on GitHub" src="img/fork.png"></img></a>
      </body>
    </html>