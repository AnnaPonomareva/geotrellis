<!DOCTYPE html SYSTEM "about:legacy-compat">
<html>
      <head>
        <title>GeoTrellis — Combined Pages</title>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/blueprint/screen.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/blueprint/grid.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/blueprint/print.css"></link> 
        <!--[if lt IE 8]>
          <link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection"/>
        <![endif]-->
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/pamflet.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/pamflet-print.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/pamflet-grid.css"></link>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/custom.css"></link>
        <script src="js/jquery-1.6.2.min.js"></script>
        <script src="js/jquery.collapse.js"></script>
        <script src="js/pamflet.js"></script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"></link><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <meta charset="utf-8"></meta>
        <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
        
      </head>
      <body>
        <a class="page prev nav" href="Contents+in+Depth.html">
            <span class="space">&nbsp;</span>
            <span class="flip">&gt;</span>
          </a>
        <div class="container">
          <div class="span-16 prepend-1 append-1">
            <div class="top nav span-16 title">
              <span>GeoTrellis</span> — Combined Pages
            </div>
          </div>
          <div class="span-16 prepend-1 append-1 contents">
            <div class="tocwrapper show">
      <a class="tochead nav" style="display: none" href="#toc">❦</a>
      <a name="toc"></a>
      <h4 class="toctitle">Contents</h4>
      <div class="tocbody">
      <div><a href="#GeoTrellis">GeoTrellis</a></div><ol class="toc"> <li><div><a href="#GeoTrellis+Resources">GeoTrellis Resources</a></div></li><li><div><a href="#Web+Service+Tutorial">Web Service Tutorial</a></div></li><li><div><a href="#Setting+up+GeoTrellis">Setting up GeoTrellis</a></div></li><li><div><a href="#GeoTrellis+Operations">GeoTrellis Operations</a></div><ol class="toc"> <li><div><a href="#Raster+Operations">Raster Operations</a></div></li><li><div><a href="#Logic+and+IO+Operations">Logic and IO Operations</a></div></li><li><div><a href="#Other+Operations">Other Operations</a></div></li> </ol></li><li><div><a href="#Creating+new+operations">Creating new operations</a></div></li><li><div><a href="#Parallel+and+distributed+execution">Parallel and distributed execution</a></div></li> </ol></div></div><h1 id="GeoTrellis">GeoTrellis</h1><p><em>GeoTrellis</em> is a high performance geoprocessing engine and programming
toolkit. The goal of the project is to transform user interaction with
geospatial data by bringing the power of geospatial analysis to real time,
interactive web applications.
</p><p>GeoTrellis was designed to solve three core problems, with a focus on raster
processing:
</p><ul><li>Creating scalable, high performance geoprocessing web services
</li><li>Creating distributed geoprocessing services that can act on large data sets
</li><li>Parallelizing geoprocessing operations to take full advantage of multi-core
architecture 
</li></ul><p>GeoTrellis is a project of Azavea (www.azavea.com), and was written by Josh
Marcus (jmarcus@azavea.com) and Erik Osheim (eosheim@azavea.com). Please
contact us if you have any questions!
</p><h2 id="Features">Features</h2><ul><li>GeoTrellis is designed to help a developer create simple, standard REST
services that return the results of geoprocessing models.
</li><li>Like an RDBS that can optimize queries, GeoTrellis will automatically
parallelize and optimize your geoprocessing models where possible.  
</li><li>In the spirit of the object-functional style of Scala, it is easy to both
create new operations and compose new operations with existing operations.
</li></ul><h2 id="Some+sample+GeoTrellis+code">Some sample GeoTrellis code</h2><pre><code class="prettyprint lang-scala">  // import the necessary stuff
  import geotrellis._
  import geotrellis.op.io
  import geotrellis.op.raster.local

  // set up the rasters and weights we'll use
  val raster1 = io.LoadRaster(&quot;foo&quot;)
  val raster2 = io.LoadRaster(&quot;bar&quot;)
  val weight1 = 5
  val weight2 = 2

  val total = weight1 + weight2

  // create a new operation that multiplies each cell of
  // each raster by a weight, and then add those two new
  // rasters together.
  val op = local.Add(local.MultiplyConstant(raster1, weight1),
                     local.MultiplyConstant(raster2, weight2))

  // create a new operation that takes the result of the
  // previous operation and divides each cell by the total
  // weight, creating a weighted overlay of our two rasters.
  val wo1 = local.DivideConstant(op, total)

  // we can use a simpler syntax if we want. note that this
  // is still just creating an operation.
  import geotrellis.Implicits._
  val wo2 = (raster1 * weight1 + raster2 * weight2) / total

  // to this point, we've only been composing new operations.
  // now we will run them.
  import geotrellis.process.Server
  val server = Server(&quot;example&quot;)
  val result1 = server.run(wo1)
  val result2 = server.run(wo2)
</code></pre><h2 id="GeoTrellis+Resources">GeoTrellis Resources</h2><h4 id="Mailing+list+and+IRC">Mailing list and IRC</h4><p>You can find us on IRC at #geotrellis on freenode, or join the user mailing list at https://groups.google.com/group/geotrellis-user.  We’re always interested in what you’re working on, if we can help, and any feedback you might have.
</p><h4 id="Scaladocs">Scaladocs</h4><p>If you want to dive directly into the code, you can find <em>Scaladocs</em>, the Scala API documentation, for the latest version of the project <a  href="http://azavea.github.com/geotrellis/latest/api/index.html#geotrellis.package">here</a>.  You can also track the current development of GeoTrellis <a  href="http://github.com/azavea/geotrellis">at our github repository</a>.
</p><h4 id="Template+Project">Template Project</h4><p>We have provided a sample project that provides a template for creating a 
geoprocessing web service with GeoTrellis. It is a blank slate for your own
development that provides a development environment that is set up with the
necessary dependencies in place, making it a little easier to get started.
</p><p>The project loads GeoTrellis as a library, includes some basic configuration,
and has a very simple “hello world” web service in place for you to edit.
The template contains <a  href="https://github.com/azavea/geotrellis-template.g8">step-by-step instructions</a>.
</p><p>If you are a first time GeoTrellis user, you can use this template with the
tutorial included in this documentation to start exploring how to build your
own geoprocessing service.
</p><h4 id="Demonstration+project">Demonstration project</h4><p>The /demo directory in the github repository includes code from the tutorial (in this guide) and a
demonstration project that provides a REST service that performs a geoprocessing operation and returns a
PNG image to the user.
</p><h2 id="Web+Service+Tutorial">Web Service Tutorial</h2><p>GeoTrellis is commonly used to build web services.
</p><p>Here we will show you how to build simple web services with Jetty that uses
GeoTrellis.
</p><h3 id="Hello+World">Hello World</h3><p>This is the most basic web service—in fact, it doesn’t directly use GeoTrellis
at all. However, it contains all the imports and objects that the other
examples will need, as well as providing an example of writing a Jetty web
service in Scala.
</p><p>This service can be accessed at <code>http://localhost:8000/greeting</code> and should
print “hello world”. You may want to substitude your own values for <code>mypackage</code>
and <code>MyApp</code>.
</p><pre><code class="prettyprint lang-scala">package mypackage

import javax.servlet.http.HttpServletRequest
import javax.ws.rs.{GET, Path, DefaultValue, PathParam, QueryParam}
import javax.ws.rs.core.{Response, Context}

import geotrellis._
import geotrellis.op._
import geotrellis.process._

object MyApp {
  val server = Server(&quot;myapp&quot;, &quot;src/main/resources/myapp-catalog.json&quot;)
  def response(mime:String)(data:Any) = Response.ok(data).`type`(mime).build()
}

@Path(&quot;/greeting&quot;)
class HelloWorld {
  @GET
  def get(@Context req:HttpServletRequest) = {
    // give a friendly greeting
    MyApp.response(&quot;text/plain&quot;)(&quot;hello world&quot;)
  }
}
</code></pre><h3 id="Adder">Adder</h3><p>With that out of the way, here’s a REST service that actually does something:
it treats the final part of the URL as a number, adds one to it, and returns
that number as plaintext. For instance, <code>http://localhost:8080/adder/127</code> would
return “128”.
</p><p>The important thing to see here is that <code>ParseInt</code> doesn’t actually do any
work. It creates an operation which when run will parse an input <code>String</code> and
return an <code>Int</code>. But running operations isn’t the only thing you can do. In our
case, <code>opX + 1</code> actually builds us a new operation, which evaluates <code>opX</code> and
then adds one to it. If there is an exception (i.e. the parameter is not a
valid number) it will only occur when <code>MyApp.server.run</code> is called.
</p><p>This means that instead of sprinkling error-handling code through your handler,
you only need to guard your calls to <code>server.run</code>. Combining operations allows
the web service author to focus on correctly encoding application logic without
having to handle errors at every possible point.
</p><p>Calling <code>server.run</code> returns an integer value which can be passed to the user.
</p><pre><code class="prettyprint lang-scala">import geotrellis.op.util.string.ParseInt
import geotrellis.Implicits._

@Path(&quot;/adder/&quot;)
class AddOne {
  @GET
  @Path(&quot;/{x}&quot;)
  def get(@PathParam(&quot;x&quot;) s:String,
          @Context req:HttpServletRequest) = {
    // parse the given integer
    val opX:Op[Int] = ParseInt(s)

    // add one
    val opY:Op[Int] = opX + 1

    // run the operation
    val data:String = try {
      val y:Int = MyApp.server.run(opY)
      y.toString
    } catch {
      case e =&gt; e.toString
    }

    MyApp.response(&quot;text/plain&quot;)(data)
  }
}
</code></pre><h3 id="Bounding+Box+Union">Bounding Box Union</h3><p>This example is similar to the previous one, but a bit more complicated: it
uses <code>geotrellis.Extent</code>, an object which represents a geographical bounding box.
The service uses two extents, each encoded in a string as
<code>xmin,ymin,xmax,ymax</code>. For example, using the Web Mercator coordinate system a
bounding box around Philadelphia might be encoded as:
</p><p><code>-8475497.88486,4825540.69147,-8317922.88486,4954765.69147</code>
</p><p>This service takes two such extents and combines them, returning the smallest
extent that contains both of them. For instance, the request:
</p><p><code>http://localhost:8000/bbox/0,0,10,10/union/5,-10,15,0</code>
</p><p>will result in <code>0,-10,15,10</code>.
</p><pre><code class="prettyprint lang-scala">import geotrellis.op.raster.extent

@Path(&quot;/bbox/&quot;)
class BoundingBox {
  @GET
  @Path(&quot;/{extent1}/union/{extent2}&quot;)
  def get(@PathParam(&quot;extent1&quot;) s1:String,
          @PathParam(&quot;extent2&quot;) s2:String,
          @Context req:HttpServletRequest) = {
    // parse the given extents
    val e1:Op[Extent] = extent.ParseExtent(s1)
    val e2:Op[Extent] = extent.ParseExtent(s2)

    // combine the extents
    val op:Op[Extent] = extent.CombineExtents(e1, e2)

    // run the operation
    val data = try {
      val extent:Extent = MyApp.server.run(op)
      extent.toString
    } catch {
      case e =&gt; e.toString
    }

    MyApp.response(&quot;text/plain&quot;)(data)
  }
}
</code></pre><h3 id="Draw+Raster">Draw Raster</h3><p>Finally, we will actually do some raster processing! This example shows how to
load raster data, create a palette of colors, assign those colors to value
rangers (classes) in the raster, and create a PNG to send to the user. Whenever
you are rendering an image for a user, you will probably need to go through
these same steps (although you may choose to hardcode the colors). 
</p><p>Given a <code>name</code>, the <code>LoadRaster</code> operation will return a <code>geotrellis.IntRaster</code>
instance containing the appropriate raster data. This class represents a file
of raster data in the <code>arg32</code> format. If you have raster data in another format
(e.g. <code>.tif</code> or <code>.asc</code>) it will need to be converted ahead of time.
</p><p>The <code>palette</code> and <code>shades</code> arguments are used to construct the color palette to
use. For example:
</p><p><code>http://localhost:8000/draw/foo/palette/ff0000,0000ff/shades/3</code>
</p><p>specifies that the palette should be a gradient from red (<code>ff0000</code>) to blue
(<code>0000ff</code>) containing 5 colors. The colors chosen in this case would be:
</p><ul><li>red (<code>ff0000</code>)
</li><li>reddish-purple (<code>bf003f</code>)
</li><li>purple (<code>7f007f</code>)
</li><li>bluish-purple (<code>3f00bf</code>)
</li><li>blue (<code>0000ff</code>)
</li></ul><p>The rest of the code builds a <code>geotrellis.stat.Histogram</code> object (using
<code>BuildMapHistogram</code>) to determine what value ranges should map to which colors
(using <code>GetColorsBreaks</code> to create a <code>geotrellis.data.ColorBreaks</code>). A full
explanation of the methodology is beyond the scope of this tutorial, but the
basic idea is to try to find ranges of equal size in the raster, so that the 5
colors are evenly used. Thus, assuming our values ranged from 0-100, we might
create the following ranges (also know as “breaks”): 
</p><ul><li>0-12: red
</li><li>13-30: reddish-purple
</li><li>31-36: purple
</li><li>37-60: bluish-purple
</li><li>61-100: blue
</li></ul><p>Finally, we render the PNG using the raster and color breaks we found.
</p><p>Again, remember that none of this work is happening until after the “run the
operation” comment. This means that any errors (e.g. invalid colors, invalid
raster, other problems) won’t happen until that point. It also means that we
could as many raster transformations as we want without needing to modify any
of the rendering code, or the error-handling.   
<br/>
One thing to note is that this code is not doing any kind of resampling or
resizing. In your own code, you will usually want to load raster data for a
particular extent (e.g. a tile) at a particular resolution (e.g. 256x256). This
services loads and renders the entire raster at its underlying resolution,
which can be slower.
</p><pre><code class="prettyprint lang-scala">import geotrellis.op.util.string.{SplitOnComma,ParseInt}

@Path(&quot;/draw/&quot;)
class DrawRaster {
  @GET
  @Path(&quot;/{name}/palette/{palette}/shades/{shades}&quot;)
  def get(@PathParam(&quot;name&quot;) name:String,
          @PathParam(&quot;palette&quot;) palette:String,
          @PathParam(&quot;shades&quot;) shades:String,
          @Context req:HttpServletRequest) = {

    // load the raster
    val rasterOp = raster.data.LoadRaster(name)

    // find the colors to use
    val paletteOp = logic.ForEach(SplitOnComma(palette))(ParseInt(_,16))
    val numOp = ParseInt(shades)
    val colorsOp = raster.stat.GetColorsFromPalette(paletteOp, numOp)

    // find the appropriate quantile class breaks to use
    val histogramOp = raster.stat.Histogram(rasterOp)
    val breaksOp = raster.stat.GetColorBreaks(histogramOp, colorsOp)

    // render the png
    val pngOp = raster.data.RenderPNG(rasterOp, breaksOp, 0, true)

    // run the operation
    try {
      val img:Array[Byte] = MyApp.server.run(pngOp)
      MyApp.response(&quot;image/png&quot;)(img)
    } catch {
      case e =&gt; MyApp.response(&quot;text/plain&quot;)(e.toString)
    }
  }
}
</code></pre><h3 id="Conclusion">Conclusion</h3><p>These services are all toys, but together they illustrate some of the concepts
used by GeoTrellis. For a more complete example please see
<code>geotrellis.rest.Demo</code> in the <code>demo</code> project which implements a more complete
weighted overlay service.
</p><h2 id="Setting+up+GeoTrellis">Setting up GeoTrellis</h2><h3 id="Configuration">Configuration</h3><p>GeoTrellis has two important configuration files:
</p><ol><li>application.conf: defines most system parameters.
</li><li>catalog.json: defines what geospatial data is available.
</li></ol><h4 id="Application+configuration">Application configuration</h4><p>The main application configuration defines important system parameters used by
your application. Some are required by GeoTrellis, while a particular
application might introduce others.
</p><p>The configuration file should be on the classpath of your application. When
using SBT, the file is often located at <code>src/main/resources/application.conf</code>.
</p><p>You can also override individual configuration parameters with Java system
properties, e.g. <code>java -Dgeotrellis.port=5555 ...</code>
</p><p>Example:
</p><pre><code class="">geotrellis.host = &quot;0.0.0.0&quot;            // server address to listen on
geotrellis.port = 8888                 // server port to listen on
geotrellis.rest-package = &quot;myapp.rest&quot; // package to search for REST services
geotrellis.tmp = &quot;/tmp&quot;                // location for temporary files
</code></pre><h4 id="Data+catalog">Data catalog</h4><p>The data catalogs is a JSON file containing information about the data
available to GeoTrellis. The catalog is made up of data stores from which data
can be loaded, and also can contain additional information about individual
layers. 
</p><p>For example, the following <code>catalog.json</code> file defines a data directory from
which any .arg files with accompanying .json metadata will be loaded.
</p><pre><code class="prettyprint lang-json">{
 &quot;catalog&quot;: &quot;my-catalog&quot;,
 &quot;stores&quot;: [
  {
   &quot;store&quot;: &quot;data:fs&quot;,
   &quot;params&quot;: {
     &quot;type&quot;: &quot;fs&quot;,
     &quot;path&quot;: &quot;/var/myapp/data&quot;
   }
  }
 ]
}
</code></pre><h3 id="Importing+Raster+Data">Importing Raster Data</h3><p>GeoTrellis uses a custom raster format, ARG (Azavea Raster Grid), to encode
raster data. This format is maximally simple to read and write, and is designed
for efficient random access.
</p><p>The most recent development version of GDAL (http://www.gdal.org/) can convert
files from most raster formats into the ARG format. This is by far the best way
to convert data to the ARG format that GeoTrellis uses for raster data.
</p><p>Please feel free to ask for advice on the mailing list on installing a recent
version of GDAL. There is also an AMI Ubuntu instance for EC2 with GeoTrellis
and a recent version of GDAL installed.  
</p><h1 id="GeoTrellis+Operations">GeoTrellis Operations</h1><p>A geoprocessing model in GeoTrellis is composed of smaller geoprocessing operations with
well-defined inputs and outputs.  The next section describes how to create your own operations, but it
is usually better to compose an operation out of existing operations if that is possible.  The following
is a list of some of the operations available.  Operations in italics are planned for the future. 
</p><p>The GeoTrellis naming convention for operations namespaces every operation within a single package, and
we commonly refer to the operation with the package name in the format “package.operation”.  For example, 
data loading operations are in the “io” package, and so the “LoadRaster” operation is referred to as “io.LoadRaster”.
</p><h2 id="Raster+Operations">Raster Operations</h2><h4 id="Local+operations">Local operations</h4><p>Raster operations that work on individual raster cells.  <a  href="http://azavea.github.com/geotrellis/latest/api/#geotrellis.raster.op.local.package">Scala package geotrellis.raster.op.local.</a>
</p><table class="bordered-table zebra-striped">
      <thead>
          <tr>
            <th>Operation</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
<tr><td><code>local.Add</code></td><td>Add the values of each cell in each raster.</td></tr>
<tr><td><code>local.Subtract</code></td><td>Subtract the values of each cell in each raster.</td></tr>
<tr><td><code>local.Multiply</code></td><td>Multiply the values of each cell in each raster.</td></tr>
<tr><td><code>local.Divide</code></td><td>Divide the values of each cell in each raster.</td></tr>
<tr><td><code>local.IfCell</code></td><td>Given a condition, set cell to value if true.</td></tr>
<tr><td><code>local.IfElseCell</code></td><td>Given a condition, set cell to true or false value.</td></tr>
<tr><td><code>local.DoCell</code></td><td>Apply a custom function to each cele.</td></tr>
<tr><td><code>local.Mask</code></td><td>Set cells in raster to NoData based on values in other raster.</td></tr>
<tr><td><code>local.Min</code></td><td>Set cells to the minimum value.</td></tr>
<tr><td><code>local.Max</code></td><td>Set cells to the maximum value.</td></tr>
<tr><td><code>local.Negate</code></td><td>Multiply cell values by -1.</td></tr>
<tr><td><code>local.Pow</code></td><td>Raise each cell to the specified power.</td></tr>
<tr><td><code>local.And</code></td><td>Apply binary bitwise and to each cell.</td></tr>
<tr><td><code>local.Not</code></td><td>Apply binary bitwise not to each cell.</td></tr>
<tr><td><code>local.Or</code></td><td>Apply binary bitwise or to each cell.</td></tr>
<tr><td><code>local.Xor</code></td><td>Apply binary bitwise xor to each cell.</td></tr>
</tbody>
</table>
<h4 id="Focal+operations">Focal operations</h4><p>Raster operations that work on raster cells and their neighbors.  <a  href="http://azavea.github.com/geotrellis/latest/api/#geotrellis.raster.op.focal.package">Scala package geotrellis.raster.op.focal.</a>
</p><table class="bordered-table zebra-striped">
      <thead>
          <tr>
            <th>Operation</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
<tr><td><code>focal.Rescale</code></td><td>Rescale values between new min and max value.</td></tr>
<tr><td><code>focal.Hillshade</code></td><td>Create a three dimensional appearance from an elevation raster.</td></tr>
<tr><td><code>focal.KernelDensity</code></td><td>Compute the kernel density of a set of points onto a raster.</td></tr>
<tr><td><code><i>focal.Aspect</i></code></td><td>Calculate downslope direction from each cell to its neighbors.</td></tr>
<tr><td><code><i>focal.Slope</i></code></td><td>Calculate maximum rate of change cell to its neighbors.</td></tr>
<tr><td><code><i>focal.FlowDirection</i></code></td><td>Calculate flow direction from input raster.</td></tr>
<tr><td><code><i>focal.CostDistance</i></code></td><td>Calculate cost distance raster.</td></tr>
<tr><td><code><i>focal.Viewshed</i></code></td><td>Calculate viewshed from input points.</td></tr>
<tr><td><code><i>focal.Mean</i></code></td><td>Set pixels to mean of specified neighborhood.</td></tr>
<tr><td><code><i>focal.Max</i></code></td><td>Set pixels to maximum value in neighborhood.</td></tr>
<tr><td><code><i>focal.Min</i></code></td><td>Set pixels to minimum value in neighborhood.</td></tr>
</tbody>
</table>
<h4 id="Zonal+operations">Zonal operations</h4><p>Raster operations that work on areas of cells that share the same value in an input raster. <a  href="http://azavea.github.com/geotrellis/latest/api/#geotrellis.raster.op.zonal.package">Scala package geotrellis.raster.op.zonal.</a>
</p><table class="bordered-table zebra-striped">
      <thead>
          <tr>
            <th>Operation</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
<tr><td><code>zonal.StandardDeviation</code></td><td>Set each cell to standard deviation within zone.</td></tr>
<tr><td><code><i>focal.Mean</i></code></td><td>Set pixels to mean of their zone.</td></tr>
<tr><td><code><i>focal.Max</i></code></td><td>Set pixels to maximum value in their zone.</td></tr>
<tr><td><code><i>focal.Min</i></code></td><td>Set pixels to minimum value in their zone.</td></tr>
</tbody>
</table>
<h2 id="Logic+and+IO+Operations">Logic and IO Operations</h2><p>These sets of operation are relevant to all compound operations as they are used to load data, produce output formats, and as the functional programming constructs that are critical to operation composition.
</p><h4 id="IO+operations">IO operations</h4><p>IO operations provide input, loading data, and output, translating the output of geoprocessing models
into output formats.  <a  href="http://azavea.github.com/geotrellis/latest/api/#geotrellis.io.op.package">Scala package geotrellis.io.op.</a>
</p><table class="bordered-table zebra-striped">
      <thead>
          <tr>
            <th>Operation</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
<tr><td><code>io.LoadFile</code></td><td>Load a raster from the provide file path.</td></tr>
<tr><td><code>io.LoadRaster</code></td><td>Load a raster by name from the catalog.</td></tr>
<tr><td><code>io.LoadRasterExtent</code></td><td>Load the raster extent by name from the catalog.</td></tr>
<tr><td><code>io.LoadRasterExtentFromFile</code></td><td>Load the raster extent by file path.</td></tr>
<tr><td><code>io.ReclassifyColorsRgba</code></td><td>Reclassify data to output color values.</td></tr>
<tr><td><code>io.RenderPNG</code></td><td>Generate a PNG from a given raster and a set of color breaks.</td></tr>
<tr><td><code>io.WritePNGFile</code></td><td>Write a PNG to disk.</td></tr>
<tr><td><code><i>io.LoadFeatures</i></code></td><td>Load vector features from catalog.</td></tr>
</tbody>
</table>
<h4 id="Logic+operations">Logic operations</h4><p>Logical operations for composing compound operations.  <a  href="http://azavea.github.com/geotrellis/latest/api/#geotrellis.logic.op.package">Scala package geotrellis.logic.op.</a>
</p><table class="bordered-table zebra-striped">
      <thead>
          <tr>
            <th>Operation</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
<tr><td><code>logic.Collect</code></td><td>Maps a sequence of operations into an operation that returns a sequence.</td></tr>
<tr><td><code>logic.Do</code></td><td>Perform a function on the input, like 'map' in functional programing.</td></tr>
<tr><td><code>logic.ForEach</code></td><td>Perform an operation on each element in a sequence.</td></tr>
</tbody>
</table>
<p>For Haskell-inspired syntax, see <a  href="http://azavea.github.com/geotrellis/latest/api/#geotrellis.logic.applicative.package">see geotrellis.logic.applicative</a> package.
</p><h2 id="Other+Operations">Other Operations</h2><h4 id="Statistics+operations">Statistics operations</h4><p>Operations for computing statistics from geographic and non-geographic data. <a  href="http://azavea.github.com/geotrellis/latest/api/#geotrellis.statistics.op.package">Scala package geotrellis.statistics.op.stat.</a>
</p><table class="bordered-table zebra-striped">
      <thead>
          <tr>
            <th>Operation</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
<tr><td><code>stat.GetHistogram</code></td><td>Returns a histogram of input values.</td></tr>
<tr><td><code>stat.GetMinMax</code></td><td>Returns minimum and maximum values.</td></tr>
<tr><td><code>stat.GetStatistics</code></td><td>Returns mean, mode, stddev, min and max.</td></tr>
<tr><td><code>stat.GetPolygonalZonalHistograms</code></td><td>Return a histogram of raster values within each zone.</td></tr>
<tr><td><code>stat.GetStandardDeviation</code></td><td>Returns standard deviation of raster values.</td></tr>
<tr><td><code><i>stat.GetVariance</i></code></td><td>Returns variance of raster values.</td></tr>
<tr><td><code>stat.GetColorBreaks</code></td><td>Returns colors for representation of raster value ranges.</td></tr>
<tr><td><code>stat.GetClassBreaks</code></td><td>Returns quantile class breaks for a given raster.</td></tr>
<tr><td><code>stat.GetColorsFromPalette</code></td><td>Perform an operation on each element in a sequence.</td></tr>
</tbody>
</table>
<h4 id="REST+Operations">REST Operations</h4><p>These operations are for use in construction of REST-style web services — the current operations are all focused on string processing.  <a  href="http://azavea.github.com/geotrellis/latest/api/#geotrellis.rest.op.string.package">Scala package geotrellis.rest.op.string.</a>
</p><table class="bordered-table zebra-striped">
      <thead>
          <tr>
            <th>Operation</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
<tr><td><code>string.Concat</code></td><td>Concatenate strings.</td></tr>
<tr><td><code>string.ParseDouble</code></td><td>Parse a string as a double.</td></tr>
<tr><td><code>string.ParseExtent</code></td><td>Parse a bounding box string as an extent.</td></tr>
<tr><td><code>string.ParseInt</code></td><td>Parse a string as an integer.</td></tr>
<tr><td><code>string.ParseHexInt</code></td><td>Parse a string as a hexidecimal integer.</td></tr>
<tr><td><code>string.Split</code></td><td>Split a string on a delimeter.</td></tr>
</tbody>
</table>
<h4 id="Vector+Operations+%280.7%29">Vector Operations (0.7)</h4><p>Vector operations operate over features such as polygons, lines, and points.  GeoTrellis vector feature
support is scheduled for a major overhaul and expansion for release 0.8, and you should consider consulting with the development team and tracking the GeoTrellis development version if you are planning on relying on existing functionality and API.  A few sample vector operations are listed below.
</p><table class="bordered-table zebra-striped">
      <thead>
          <tr>
            <th>Operation</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
<tr><td><code>data.RasterizePolygon</code></td><td>Create raster representation of vector data.</td></tr>
<tr><td><code>data.SplitMultiPolygon</code></td><td>Split multipolygon in to individual polygons.</td></tr>
<tr><td><code>geometry.Intersect</code></td><td>Return the intersection of input geometries.</td></tr>
<tr><td><code>extent.PolygonExtent</code></td><td>Return the bounding box of the input polygon.</td></tr>
</tbody>
</table>
<h2 id="Creating+new+operations">Creating new operations</h2><p>Ideally, a new geoprocessing service can be composed with existing operations
that have already been created for you.  The tutorial, for example, shows a
series of examples of a service being created by composing existing operations.
</p><p>But sometimes it is necessary to create new operations instead of simply
composing a new process with existing operations. There is a short method and
the full method creating new operations.
</p><p>When thinking about operations, think about them like a mathematical function—
operations take input and produce an output.  The inputs to all operations are 
operations themselves.  You can think about this as a data pipeline, in which
each operation’s output is connected to the input of its parent operations.
</p><h4 id="Short+method">Short method</h4><p>Let’s create a simple operation that adds two integers together.
</p><p>We’ll make an operation that can be instantiated with the following code:
</p><pre><code class="prettyprint lang-scala">val a = AddInts(1, 2)
val result = server.run(a)
</code></pre><p>This is an example of using the short method to define an operation:
</p><pre><code class="prettyprint lang-scala">case class AddInts(a:Op[Int], b:Op[Int]) extends Op2(a, b) ({
  (a, b) =&gt; {
    a + b
  }
})
</code></pre><p>The operation above is called <code>AddInts</code>.  <code>Op</code> is short for Operation.
Right after AddInts are the inputs to this operation, called <code>a</code> and <code>b</code>.
The declaration <code>a:Op[Int]</code> means that the first input is of the type <code>Op[Int]</code>.
<code>[Int]</code> is the type parameter of <code>Op</code>, and it means that a is an operation
that outputs an Int (an integer). The class <code>AddInts</code> exends the class
<code>Op2</code>, which means that it is an operation that takes two inputs. If this
operation had only 1 input, we’d use <code>Op1</code> instead of <code>Op2</code>. 
</p><p>For example:
</p><pre><code class="prettyprint lang-scala">case class AddOne(a:Op[Int]) extends Op1(a) ({
  (a) =&gt; {
    a + 1
  }
})
</code></pre><p>The syntax in the middle, e.g.:
</p><pre><code class="prettyprint lang-scala">  (a,b) =&gt; {
    a + b
  }
</code></pre><p>means that we are making a function that takes two arguments (a and b) and we
define the body of the function that does the actual work with the inputs
between the two braces.
</p><p>You can see lots of examples of Operations in <code>src/main/geotrellis/op</code>.
</p><h4 id="Full+method">Full method</h4><p>Instead of the short syntax (in which operations extend <code>Op1</code>..<code>OpN</code>) you can
create a class which extends <code>Op[T]</code>. This approach exposes the underlying
methods that operations use to load data (via the <code>Context</code> object) and also to
stage calculations across multipe steps.
</p><pre><code class="prettyprint lang-scala">case class Add(a:Op[Int], b:Op[Int]) extends Op[Int] {
  def _run(context:Context) = {
    runAsync(List(a, b))
  }
  def nextSteps:Steps = {
    case (a:Int) :: (b:Int) :: Nil =&gt; {
      a + b
    }
  }
}
</code></pre><p>The _run method is where the execution of the operation begins. We call
<code>runAsync</code> with a list of operations to tell the server to asynchronous execute
our child operations, and then the partial function <code>nextSteps</code> is executed
when all of the results have been retrieved.
</p><p>If we need to pass any information forward, we can include it in the List given
to <code>runAsync</code> All operations passed to <code>runAsync</code> will be executed (in
parallel), while other values will simply be passed through. The resulting list
will be matched against <code>nextSteps</code>, which will continue executing the
calculation. The syntax used in <code>nextSteps</code> (involving one of more <code>case</code>
statements) is the same as other pattern matching in Scala.
</p><p>For example, the following code tries to find the pattern of a two-element list
where the first element and second elements are integers. If the input matches
this pattern, it saves the first element in <code>a</code> and the second in <code>b</code> and
executes the provide block of code.
</p><p>If you want to understand more about the machinery at work here, see the
<em>Architecture Concepts</em> section and the Server code
(<code>geotrellis/process/server.scala</code> and <code>geotrellis/process/actors.scala</code>).
</p><h2 id="Parallel+and+distributed+execution">Parallel and distributed execution</h2><h4 id="Parallel+Execution">Parallel Execution</h4><p>Most operations have “child operations” which are the inputs or incoming data
streams that the operation acts on. GeoTrellis will automatically run all child
operations in parallel. For example, if you are adding each cell of five
rasters together, the service will calculate each input raster in parallel (if
resources allow).
</p><p>If working with a single large data set (e.g. a large raster), it is usually
beneficial to transform the raster into a tiled raster which allows the system
to parallelize the work and to reduce I/O.
</p><h4 id="Distributed+Execution">Distributed Execution</h4><p>With a single command, an operation can be transformed into a RemoteOperation
that sends each of its child operations to a remote GeoTrellis server for
execution.
</p><pre><code class="prettyprint lang-scala">// calculate each input raster on remote cluster
local.Add(r1,r2,r3).remote(cluster)
</code></pre><p>The remote cluster or server is an Akka actor or load balancer, defined using
the Akka library configuration. See the <a  href="http://akka.io/docs/akka/2.0-M4">Akka documenation</a>
for more information. Akka configuration can be placed directly in your
GeoTrellis configuration file (application.conf).
</p><p>For operations that do not need to pass much data over the network, the
overhead can be as low as a few milliseconds. When passing raster data, the
time overhead depends on the network and the size of the rasters. 
</p><h4 id="Architecture+Concepts">Architecture Concepts</h4><p>Behind the scenes, GeoTrellis is using the actor model for parallel and
distributed computation—the primary abstraction is message passing instead of
shared memory. This event-based model allows us to re-use the same threads by
interleaving calculations for different processes on the same threads, but
requires operations to be asynchronous. Operations are not allowed to block
while waiting on another result because that would hold up the other work that
is scheduled to execute on the same thread. 
</p><p>By using the <a  href="http://en.wikipedia.org/wiki/Continuation-passing_style">continuation passing style</a>
from functional programming we perform work in a series of stages:
</p><ul><li>Calculation begins on a particular thread.
</li><li>If calculation can complete, it does so (and we are done).
</li><li>Otherwise, the calculation and its subsidiaries are sent to a dispatcher.
</li><li>Calculation exits, freeing the thread.
</li><li>Subsidiary calculations are sent to new threads to be processed.
</li><li>When all subsidiary results are available, the next calculation step begins on a new thread.
</li></ul><p>Thus, we can perform complex calculations across many threads, without ever
blocking execution on an individual thread.
</p><p>Operations are sent as immutable messages, and are referrentially transparent.
This allows us to perform optimizations such as combining  
<br/>
local raster operations. 
</p>
          </div>
        </div>
        <a class="fork nav" href="http://github.com/azavea/geotrellis"><img alt="Fork me on GitHub" src="img/fork.png"></img></a>
      </body>
    </html>