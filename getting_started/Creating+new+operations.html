<html>
      <head>
        <title>GeoTrellis — Creating new operations</title>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/blueprint/screen.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/blueprint/grid.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/blueprint/print.css"></link> 
        <!--[if lt IE 8]>
          <link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection"/>
        <![endif]-->
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/pamflet.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/pamflet-print.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/pamflet-grid.css"></link>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/custom.css"></link>
        <script src="js/jquery-1.6.2.min.js"></script>
        <script src="js/pamflet.js"></script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"></link><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <meta charset="utf-8"></meta>
        <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      </head>
      <body>
        <a class="page prev nav" href="Operations.html">
            <span class="space">&nbsp;</span>
            <span class="flip">❧</span>
          </a><a class="page next nav" href="Parallel+and+distributed+execution.html">
            <span class="space">&nbsp;</span>
            <span>❧</span>
          </a>
        <div class="container">
          <div class="span-16 prepend-1 append-1">
            <div class="top nav span-16 title">
              <span>GeoTrellis</span>
               — Creating new operations
            </div>
          </div>
          <div class="span-16 prepend-1 append-1 contents">
            <h2 id="Creating+new+operations">Creating new operations</h2><p>Ideally, a new geoprocessing service can be composed with existing operations that
have already been created for you.  The tutorial, for example, shows a series of
examples of a service being created by composing existing operations.  But sometimes
it is necessary to create new operations instead of simply composing a new process with
existing operations.  There is a short method and the full method creating new operations.
</p><p>When thinking about operations, think about them like a mathematical function — 
operations take input and produce an output.  The inputs to all operations are 
operations themselves.  You can think about this as a data pipeline, in which
each operation’s output is connected to the input of its parent operations.
</p><h3 id="Short+method">Short method</h3><p>Let’s create a simple operation that adds two integers together.
</p><p>We’ll make an operation that can be instantiated with the following code:
</p><pre><code class="prettyprint lang-scala">val a = AddInts(1,2)
val result = server.run(a)
</code></pre><p>This is an example of using the short method to define an operation:
</p><pre><code class="prettyprint lang-scala">case class AddInts(a:Op[Int], b:Op[Int]) extends Op2(a,b) ({
  (a,b) =&gt; {
    a + b
  }
})
</code></pre><p>The operation above is called <code>AddInts</code>.  <code>Op</code> is short for Operation.
Right after AddInts are the inputs to this operation, called <code>a</code> and <code>b</code>.
The declaration <code>a:Op[Int]</code> means that the first input is of the type <code>Op[Int]</code>.
<code>[Int]</code> is the type parameter of <code>Op</code>, and it means that a is an operation that outputs
an Int, an integer.  The class <code>AddInts</code> exends the class <code>Op2</code>, which means that it is
an operation that takes two inputs.  If this operation had only 1 input, we’d use <code>Op1</code> instead of <code>Op2</code>.  For example,
</p><pre><code class="prettyprint lang-scala">case class AddOne(a:Op[Int]) extends Op1(a) ({
  (a) =&gt; {
    a + 1
  }
})
</code></pre><p>The syntax in the middle, e.g.:
</p><pre><code class="prettyprint lang-scala">  (a,b) =&gt; {
    a + b
  }
</code></pre><p>means that we are making a function that takes two arguments (a and b) and we define the
body of the function that does the actual work with the inputs between the two braces.
</p><p>You can see lots of examples of Operations in the src/main/geotrellis/operation directory.
</p><h3 id="Full+method">Full method</h3><p>Instead of the short syntax (in which operations extend Op1..OpN) you can use subclass
Operation[T].  By directly extending Operation you gain access ot the Context object
(which allows data loading) and can create multiple steps.  
</p><pre><code class="prettyprint lang-scala">case class Add(a:Op[Int], b:Op[Int]) extends Operation[Int] {
  def _run(context:Context) = {
    runAsync(List(a,b))
  }
  def nextSteps:Steps = {
    case (a:Int) :: (b:Int) :: Nil =&gt; {
      a + b
    }
  }
}
</code></pre><p>The _run method is where the execution of the Operation begins.  We call ‘runAsync’
with a list of operations to tell the server to asynchronous execute our child operations,
and then the partial function nextSteps is executed when all of the results have been 
retrieved.  If we need to pass any information forward, we can include it in the List given
to runAsync.  When the nextSteps method matches the results received, it can execute the
next step of the calculation.  If you’re not familar with the syntax in nextSteps, learn
more about pattern matching in scala.  
<br/>
For example, the following code tries to find the pattern of a two-element list where the first element and second elements are integers.  If the input matches this pattern, it
saves the first element in <code>a</code> and the second in <code>b</code> and executes the provide block
of code.
</p><pre><code class="prettyprint lang-scala">  case (a:Int) :: (b:Int) :: Nil =&gt; {
</code></pre><p>If you want to understand more about the machinery at work here, see the <em>Architecture Concepts</em> section and the Server code (src/main/process/server.scala and src/main/process/actors.scala).
</p><h4>Contents</h4><div><a href="GeoTrellis.html">GeoTrellis</a></div><ol class="toc"> <li><div><a href="API+Reference.html">API Reference</a></div></li><li><div><a href="Get+started+with+the+template+project.html">Get started with the template project</a></div></li><li><div><a href="Web+Service+Tutorial.html">Web Service Tutorial</a></div></li><li><div><a href="Setting+up+GeoTrellis.html">Setting up GeoTrellis</a></div></li><li><div><a href="Operations.html">Operations</a></div></li><li><div class="current">Creating new operations</div></li><li><div><a href="Parallel+and+distributed+execution.html">Parallel and distributed execution</a></div></li><li class="generated"><div><a href="Contents+in+Depth.html">Contents in Depth</a></div></li><li class="generated"><div><a href="Combined+Pages.html">Combined Pages</a></div></li> </ol>
          </div>
        </div>
        <a class="fork nav" href="http://github.com/azavea/geotrellis"><img alt="Fork me on GitHub" src="img/fork.png"></img></a>
      </body>
    </html>