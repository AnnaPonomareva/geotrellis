<html>
      <head>
        <title>GeoTrellis — Web Service Tutorial</title>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/blueprint/screen.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/blueprint/grid.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/blueprint/print.css"></link> 
        <!--[if lt IE 8]>
          <link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection"/>
        <![endif]-->
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/pamflet.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/pamflet-print.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/pamflet-grid.css"></link>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/custom.css"></link>
        <script src="js/jquery-1.6.2.min.js"></script>
        <script src="js/pamflet.js"></script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"></link><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <meta charset="utf-8"></meta>
        <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      </head>
      <body>
        <a class="page prev nav" href="Get+started+with+the+template+project.html">
            <span class="space">&nbsp;</span>
            <span class="flip">❧</span>
          </a><a class="page next nav" href="Setting+up+GeoTrellis.html">
            <span class="space">&nbsp;</span>
            <span>❧</span>
          </a>
        <div class="container">
          <div class="span-16 prepend-1 append-1">
            <div class="top nav span-16 title">
              <span>GeoTrellis</span>
               — Web Service Tutorial
            </div>
          </div>
          <div class="span-16 prepend-1 append-1 contents">
            <h2 id="Web+Service+Tutorial">Web Service Tutorial</h2><p>GeoTrellis is commonly used to build web services.
</p><p>Here we will show you how to build simple web services with Jetty that use
GeoTrellis.
</p><h3 id="Hello+World">Hello World</h3><p>This is the most basic web service—in fact, it doesn’t directly use GeoTrellis
at all. However, it contains all the imports and objects that the other
examples will need, as well as providing an example of writing a Jetty web
service in Scala.
</p><p>This service can be accessed at <code>http://localhost:8000/greeting</code> and should
print “hello world”. You may want to substitude your own values for <code>myapp</code> and
<code>endpoint</code>.
</p><pre><code class="prettyprint lang-scala">package geotrellis.rest.myapp

import javax.servlet.http.HttpServletRequest
import javax.ws.rs.{GET, Path, DefaultValue, PathParam, QueryParam}
import javax.ws.rs.core.{Response, Context}

import geotrellis._
import geotrellis.operation._
import geotrellis.process._

object MyApp {
  val server = Server(&quot;myapp&quot;, &quot;src/main/resources/myapp-catalog.json&quot;)
  def response(mime:String)(data:Any) = Response.ok(data).`type`(mime).build()
}

@Path(&quot;/greeting&quot;)
class HelloWorld {
  @GET
  def get(@Context req:HttpServletRequest) = {
    // give a friendly greeting
    MyApp.response(&quot;text/plain&quot;)(&quot;hello world&quot;)
  }
}
</code></pre><h3 id="Adder">Adder</h3><p>With that out of the way, here’s a REST service that actually does something:
it treats the final part of the URL as a number, adds one to it, and returns
that number as plaintext. For instance, <code>http://localhost:8080/adder/127</code> would
return “128”.
</p><p>The important thing to see here is that <code>ParseInt</code> doesn’t actually do any
work. It creates an operation which when run will parse an input <code>String</code> and
return an <code>Int</code>. But running operations isn’t the only thing you can do. In our
case, <code>opX + 1</code> actually builds us a new operation, which evaluates <code>opX</code> and
then adds one to it. If there is an exception (i.e. the parameter is not a
valid number) it will only occur when <code>MyApp.server.run</code> is called.
</p><p>This means that instead of sprinkling error-handling code through your handler,
you only need to guard your calls to <code>server.run</code>. Combining operations allows
the web service author to focus on correctly encoding application logic without
having to handle errors at every possible point.
</p><p>Calling <code>server.run</code> returns an integer value which can be passed to the user.
</p><pre><code class="prettyprint lang-scala">@Path(&quot;/adder/&quot;)
class AddOne {
  @GET
  @Path(&quot;/{x}&quot;)
  def get(@PathParam(&quot;x&quot;) s:String,
          @Context req:HttpServletRequest) = {
    // parse the given integer
    val opX:Op[Int] = ParseInt(s)

    // add one
    val opY:Op[Int] = opX + 1

    // run the operation
    val data:String = try {
      val y:Int = MyApp.server.run(opY)
      y.toString
    } catch {
      case e =&gt; e.toString
    }

    MyApp.response(&quot;text/plain&quot;)(data)
  }
}
</code></pre><h3 id="Bounding+Box+Union">Bounding Box Union</h3><p>This example is similar to the previous one, but a bit more complicated: it
uses <code>geotrellis.Extent</code>, an object which represents a geographical bounding box.
The service uses two extents, each encoded in a string as
<code>xmin,ymin,xmax,ymax</code>. For example, using the Web Mercator coordinate system a
bounding box around Philadelphia might be encoded as:
</p><p><code>-8475497.88486,4825540.69147,-8317922.88486,4954765.69147</code>
</p><p>This service takes two such extents and combines them, returning the smallest
extent that contains both of them. For instance, the request:
</p><p><code>http://localhost:8000/bbox/0,0,10,10/union/5,-10,15,0</code>
</p><p>will result in <code>0,-10,15,10</code>.
</p><pre><code class="prettyprint lang-scala">@Path(&quot;/bbox/&quot;)
class BoundingBox {
  @GET
  @Path(&quot;/{extent1}/union/{extent2}&quot;)
  def get(@PathParam(&quot;extent1&quot;) s1:String,
          @PathParam(&quot;extent2&quot;) s2:String,
          @Context req:HttpServletRequest) = {
    // parse the given extents
    val e1:Op[Extent] = ParseExtent(s1)
    val e2:Op[Extent] = ParseExtent(s2)

    // combine the extents
    val op:Op[Extent] = CombineExtents(e1, e2)

    // run the operation
    val data = try {
      val extent:Extent = MyApp.server.run(op)
      extent.toString
    } catch {
      case e =&gt; e.toString
    }

    MyApp.response(&quot;text/plain&quot;)(data)
  }
}
</code></pre><h3 id="Draw+Raster">Draw Raster</h3><p>Finally, we will actually do some raster processing! This example shows how to
load raster data, create a palette of colors, assign those colors to value
rangers (classes) in the raster, and create a PNG to send to the user. Whenever
you are rendering an image for a user, you will probably need to go through
these same steps (although you may choose to hardcode the colors). 
</p><p>Given a <code>name</code>, the <code>LoadRaster</code> operation will return a <code>geotrellis.IntRaster</code>
instance containing the appropriate raster data. This class represents a file
of raster data in the <code>arg32</code> format. If you have raster data in another format
(e.g. <code>.tif</code> or <code>.asc</code>) it will need to be converted ahead of time.
</p><p>The <code>palette</code> and <code>shades</code> arguments are used to construct the color palette to
use. For example:
</p><p><code>http://localhost:8000/draw/foo/palette/ff0000,0000ff/shades/3</code>
</p><p>specifies that the palette should be a gradient from red (<code>ff0000</code>) to blue
(<code>0000ff</code>) containing 5 colors. The colors chosen in this case would be:
</p><ul><li>red (<code>ff0000</code>)
</li><li>reddish-purple (<code>bf003f</code>)
</li><li>purple (<code>7f007f</code>)
</li><li>bluish-purple (<code>3f00bf</code>)
</li><li>blue (<code>0000ff</code>)
</li></ul><p>The rest of the code builds a <code>geotrellis.stat.Histogram</code> object (using
<code>BuildMapHistogram</code>) to determine what value ranges should map to which colors
(using <code>FindColorsBreaks</code> to create a <code>geotrellis.data.ColorBreaks</code>). A full
explanation of the methodology is beyond the scope of this tutorial, but the
basic idea is to try to find ranges of equal size in the raster, so that the 5
colors are evenly used. Thus, assuming our values ranged from 0-100, we might
create the following ranges (also know as “breaks”): 
</p><ul><li>0-12: red
</li><li>13-30: reddish-purple
</li><li>31-36: purple
</li><li>37-60: bluish-purple
</li><li>61-100: blue
</li></ul><p>Finally, we render the PNG using the raster and color breaks we found.
</p><p>Again, remember that none of this work is happening until after the “run the
operation” comment. This means that any errors (e.g. invalid colors, invalid
raster, other problems) won’t happen until that point. It also means that we
could as many raster transformations as we want without needing to modify any
of the rendering code, or the error-handling.   
<br/>
One thing to note is that this code is not doing any kind of resampling or
resizing. In your own code, you will usually want to load raster data for a
particular extent (e.g. a tile) at a particular resolution (e.g. 256x256). This
services loads and renders the entire raster at its underlying resolution,
which can be slower.
</p><pre><code class="prettyprint lang-scala">@Path(&quot;/draw/&quot;)
class DrawRaster {
  @GET
  @Path(&quot;/{name}/palette/{palette}/shades/{shades}&quot;)
  def get(@PathParam(&quot;name&quot;) name:String,
          @PathParam(&quot;palette&quot;) palette:String,
          @PathParam(&quot;shades&quot;) shades:String,
          @Context req:HttpServletRequest) = {

    // load the raster
    val rasterOp = LoadRaster(name)

    // find the colors to use
    val paletteOp = ForEach(SplitOnComma(palette))(ParseHexInt(_))
    val numOp = ParseInt(shades)
    val colorsOp = ColorsFromPalette(paletteOp, numOp)

    // find the appropriate quantile class breaks to use
    val histogramOp = BuildMapHistogram(rasterOp)
    val breaksOp = FindColorBreaks(histogramOp, colorsOp)

    // render the png
    val pngOp = RenderPNG(rasterOp, breaksOp, 0, true)

    // run the operation
    try {
      val img:Array[Byte] = MyApp.server.run(pngOp)
      MyApp.response(&quot;image/png&quot;)(img)
    } catch {
      case e =&gt; MyApp.response(&quot;text/plain&quot;)(e.toString)
    }
  }
}
</code></pre><h3 id="Conclusion">Conclusion</h3><p>These services are all toys, but hopefully illustrate (and explain) some of the
concepts and objects used by GeoTrellis. For a more complete example please see
<code>geotrellis.rest.Demo</code> which implements a weighted overlay service.
</p><h4>Contents</h4><div><a href="GeoTrellis.html">GeoTrellis</a></div><ol class="toc"> <li><div><a href="API+Reference.html">API Reference</a></div></li><li><div><a href="Get+started+with+the+template+project.html">Get started with the template project</a></div></li><li><div class="current">Web Service Tutorial</div></li><li><div><a href="Setting+up+GeoTrellis.html">Setting up GeoTrellis</a></div></li><li><div><a href="Operations.html">Operations</a></div></li><li><div><a href="Creating+new+operations.html">Creating new operations</a></div></li><li><div><a href="Parallel+and+distributed+execution.html">Parallel and distributed execution</a></div></li><li class="generated"><div><a href="Contents+in+Depth.html">Contents in Depth</a></div></li><li class="generated"><div><a href="Combined+Pages.html">Combined Pages</a></div></li> </ol>
          </div>
        </div>
        <a class="fork nav" href="http://github.com/azavea/geotrellis"><img alt="Fork me on GitHub" src="img/fork.png"></img></a>
      </body>
    </html>