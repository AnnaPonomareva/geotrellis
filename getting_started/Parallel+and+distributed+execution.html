<html >
      <head>
        <title>GeoTrellis — Parallel and distributed execution</title>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/blueprint/screen.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/blueprint/grid.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/blueprint/print.css"></link> 
        <!--[if lt IE 8]>
          <link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection"/>
        <![endif]-->
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/pamflet.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/pamflet-print.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/pamflet-grid.css"></link>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/custom.css"></link>
        <script src="js/jquery-1.6.2.min.js"></script>
        <script src="js/pamflet.js"></script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"></link><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <meta charset="utf-8"></meta>
        <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      </head>
      <body>
        <a class="page prev nav" href="Creating+new+operations.html">
            <span class="space">&nbsp;</span>
            <span class="flip">❧</span>
          </a><a class="page next nav" href="Contents+in+Depth.html">
            <span class="space">&nbsp;</span>
            <span>❧</span>
          </a>
        <div class="container">
          <div class="span-16 prepend-1 append-1">
            <div class="top nav span-16 title">
              <span>GeoTrellis</span>
               — Parallel and distributed execution
            </div>
          </div>
          <div class="span-16 prepend-1 append-1 contents">
            <h2 id="Parallel+and+distributed+execution">Parallel and distributed execution</h2><h3 id="Parallel+Execution">Parallel Execution</h3><p>Most operations have “child operations” which are the inputs or incoming data streams
that the operation acts on.  GeoTrellis will automatically run all child operations in
parallel.  For example, if you are adding each cell of five rasters together, the
service will calculate each input raster in parallel (if resources allow).  If working
with a single large data set (e.g. a large raster), it is usually beneficial to transform
the raster into a <code>TiledRaster</code> which allows the system to parallelize the work. 
</p><h3 id="Distributed+Execution">Distributed Execution</h3><p>With a single command, an operation can be transformed into a RemoteOperation that
sends each of its child operations to a remote GeoTrellis server for execution.  
</p><pre><code class="prettyprint lang-scala">Add(r1,r2,r3).remote(cluster) // calculate input rasters on remote cluster
</code></pre><p>The remote cluster or server is an Akka actor or load balancer, defined using the Akka 
library configuration.  See the <a  href="http://akka.io/docs/akka/2.0-M4">Akka documenation</a> for more information.  Akka configuration can be placed directly in your GeoTrellis configuration file (application.conf). 
</p><p>For operations that do not need to pass much data over the network, the overhead can be as 
low as a few milliseconds.  When passing raster data, the time overhead depends on the
network and the size of the rasters. 
</p><h3 id="Architecture+Concepts">Architecture Concepts</h3><p>Behind the scenes, GeoTrellis is using the actor model for parallel and distributed computation, which means that the primary abstraction is message passing instead of shared memory.  This event-based model allows us to re-use the same threads by interleaving calculations for different processes on the same threads, but this means that nothing can ever block or stop on a thread while waiting for another result because that would hold up the other work that is scheduled to execute on the same thread.  By using the <a  href="http://en.wikipedia.org/wiki/Continuation-passing_style">continuation passing style</a> from functional programming we can perform work in a series of stages, in which requests
are first sent out for calculations to be processed and then when all of the results
are received, we can execute the next step of the calculation, without ever blocking
execution on an individual thread.  Operations are sent as immutable messages, and should
be referrentially transparent, which allows us to perform optimizations such as combining
local raster operations. 
</p><h4>Contents</h4><div><a href="GeoTrellis.html">GeoTrellis</a></div><ol class="toc"> <li><div><a href="API+Reference.html">API Reference</a></div></li><li><div><a href="Get+started+with+the+template+project.html">Get started with the template project</a></div></li><li><div><a href="Web+Service+Tutorial.html">Web Service Tutorial</a></div></li><li><div><a href="Setting+up+GeoTrellis.html">Setting up GeoTrellis</a></div></li><li><div><a href="Operations.html">Operations</a></div></li><li><div><a href="Creating+new+operations.html">Creating new operations</a></div></li><li><div class="current">Parallel and distributed execution</div></li><li class="generated"><div><a href="Contents+in+Depth.html">Contents in Depth</a></div></li><li class="generated"><div><a href="Combined+Pages.html">Combined Pages</a></div></li> </ol>
          </div>
        </div>
        <a class="fork nav" href="http://github.com/azavea/geotrellis"><img alt="Fork me on GitHub" src="img/fork.png"></img></a>
      </body>
    </html>