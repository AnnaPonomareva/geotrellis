<html manifest="pamflet.manifest">
      <head>
        <title>Arpeggeo — Parallel and Distributed Calculation</title>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/blueprint/screen.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/blueprint/grid.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/blueprint/print.css"></link> 
        <!--[if lt IE 8]>
          <link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection"/>
        <![endif]-->
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/pamflet.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/pamflet-print.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/pamflet-grid.css"></link>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/custom.css"></link>
        <script src="js/jquery-1.6.2.min.js"></script>
        <script src="js/pamflet.js"></script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"></link><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <meta charset="utf-8"></meta>
        <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      </head>
      <body>
        <a class="page prev nav" href="Creating+Operations.html">
            <span class="space">&nbsp;</span>
            <span class="flip">❧</span>
          </a><a class="page next nav" href="Contents+in+Depth.html">
            <span class="space">&nbsp;</span>
            <span>❧</span>
          </a>
        <div class="container">
          <div class="span-16 prepend-1 append-1">
            <div class="top nav span-16 title">
              <span>Arpeggeo</span>
               — Parallel and Distributed Calculation
            </div>
          </div>
          <div class="span-16 prepend-1 append-1 contents">
            <h2 id="Parallel+and+Distributed+Calculation">Parallel and Distributed Calculation</h2><h3 id="Parallel+Execution">Parallel Execution</h3><p>Most operations have “child operations” which are the inputs or incoming data streams
that the operation acts on.  Arpeggeo will automatically run all child operations in
parallel.  For example, if you are adding each cell of five rasters together, the
service will calculate each input raster in parallel (if resources allow).  If working
with a single large data set (e.g. a large raster), it is usually beneficial to transform
the raster into a <code>TiledRaster</code> which allows the system to parallelize the work. 
</p><h3 id="Distributed+Execution">Distributed Execution</h3><p>With a single command, an operation can be transformed into a RemoteOperation that
sends each of its child operations to a remote Arpeggeo server for execution.  
</p><pre><code class="prettyprint lang-scala">Add(r1,r2,r3).remote(cluster) // calculate input rasters on remote cluster
</code></pre><p>The remote cluster or server is an Akka actor or load balancer, defined using the Akka 
library configuration.  See the Akka documenation for more information.  (http://akka.io/docs/akka/2.0-M4/)
</p><p>For operations that do not need to pass data over the network, the overhead can be as 
low as a few milliseconds.  When passing raster data, the time overhead depends on the
network and the size of the rasters, but an operation that sends and receives a 256x256 raster tile can be executed in under 15ms, 512x512 in ~30ms, etc.
</p><h3 id="Architecture">Architecture</h3><p>Behind the scenes, Arpeggeo is using the actor model for parallel and distributed computation, which means that the primary abstraction is message passing instead of shared memory.  This event-based model allows us to re-use the same threads by interleaving calculations for different processes on the same threads, but this means that nothing can ever block or stop on a thread while waiting for another result because that would hold up the other work that is scheduled to execute on the same thread.  By using the continuation passing style from functional programming (http://en.wikipedia.org/wiki/Continuation-passing_style) we can perform work in a series of stages, in which requests
are first sent out for calculations to be processed and then when all of the results
are received, we can execute the next step of the calculation, without ever blocking
execution on an individual thread.  Operations are sent as immutable messages, and should
be referrentially transparent, which allows us to perform optimizations such as combining
local raster operations. 
</p><h4>Contents</h4><div><a href="Arpeggeo.html">Arpeggeo</a></div><ol class="toc"> <li><div><a href="API+Reference.html">API Reference</a></div></li><li><div><a href="Operations.html">Operations</a></div></li><li><div><a href="Setting+up+Arpeggeo.html">Setting up Arpeggeo</a></div></li><li><div><a href="Using+the+template+project.html">Using the template project</a></div></li><li><div><a href="Creating+Operations.html">Creating Operations</a></div></li><li><div class="current">Parallel and Distributed Calculation</div></li><li class="generated"><div><a href="Contents+in+Depth.html">Contents in Depth</a></div></li><li class="generated"><div><a href="Combined+Pages.html">Combined Pages</a></div></li> </ol>
          </div>
        </div>
        <a class="fork nav" href="http://github.com/azavea/trellis"><img alt="Fork me on GitHub" src="img/fork.png"></img></a>
      </body>
    </html>