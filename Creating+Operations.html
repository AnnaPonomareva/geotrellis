<html manifest="pamflet.manifest">
      <head>
        <title>Arpeggeo — Creating Operations</title>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/blueprint/screen.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/blueprint/grid.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/blueprint/print.css"></link> 
        <!--[if lt IE 8]>
          <link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection"/>
        <![endif]-->
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/pamflet.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/pamflet-print.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/pamflet-grid.css"></link>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/custom.css"></link>
        <script src="js/jquery-1.6.2.min.js"></script>
        <script src="js/pamflet.js"></script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"></link><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <meta charset="utf-8"></meta>
        <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      </head>
      <body>
        <a class="page prev nav" href="Using+the+template+project.html">
            <span class="space">&nbsp;</span>
            <span class="flip">❧</span>
          </a><a class="page next nav" href="Parallel+and+Distributed+Calculation.html">
            <span class="space">&nbsp;</span>
            <span>❧</span>
          </a>
        <div class="container">
          <div class="span-16 prepend-1 append-1">
            <div class="top nav span-16 title">
              <span>Arpeggeo</span>
               — Creating Operations
            </div>
          </div>
          <div class="span-16 prepend-1 append-1 contents">
            <h2 id="Creating+Operations">Creating Operations</h2><p>Ideally, a new geoprocessing service can be composed with existing operations that
have already been created for you.  The tutorial, for example, shows a series of
examples of a service being created by composing existing operations.  But sometimes
it is necessary to create new operations instead of simply composing a new process with
existing operations.  There is a simple and an advanced structure for creating new operations.
</p><h3 id="Simple">Simple</h3><h3 id="Advanced">Advanced</h3><h4 id="Parallel+and+Distributed+Calculation">Parallel and Distributed Calculation</h4><p>While it’s not necessary to understand why we follow the pattern above, here is a quick 
explanation if you’re curious.  Behind the scenes, Arpeggeo is using the actor model for parallel and distributed computation, which means that the primary abstraction is message passing instead of shared memory.  This event-based model allows us to re-use the same threads by interleaving calculations for different processes on the same threads, but this means that nothing can ever block or stop on a thread while waiting for another result because that would hold up the other work that is scheduled to execute on the same thread.  By using the continuation passing style from functional programming (http://en.wikipedia.org/wiki/Continuation-passing_style) we can perform work in a series of stages, in which requests
are first sent out for calculations to be processed and then when all of the results
are received, we can execute the next step of the calculation, without ever blocking
execution on an individual thread.
</p><h2 id="Running+operations">Running operations</h2><h3 id="Parallel+execution">Parallel execution</h3><h3 id="Distributed+execution">Distributed execution</h3><ul><li>When an operation is 
</li></ul><p><em>Arpeggeo</em> is a high performance geoprocessing engine and programming toolkit.  The goal of the project is to transform
user interaction with geospatial data by bringing the power of geospatial analysis to real time, interactive web applications.
</p><p>Arpeggeo was designed to solve three core problems, with a focus on raster processing:
</p><ul><li>Creating scalable, high performance geoprocessing web services
</li><li>Creating distributed geoprocessing services that can act on large data sets
</li><li>Parallelizing geoprocessing operations to take full advantage of multi-core architecture 
</li></ul><p>Arpeggeo is a project of Azavea (www.azavea.com), and was written by Josh Marcus (jmarcus@azavea.com) and Erik Osheim (eosheim@azavea.com).  Please contact us if you have any questions!
</p><h2 id="Features">Features</h2><ul><li>Arpeggeo is designed to help a developer create simple, standard REST services that return the results of geoprocessing models.
</li><li>Like an RDBS that can optimize queries, Arpeggeo will automatically parallelize and optimize your geoprocessing models where possible.  
</li><li>In the spirit of the object-functional style of Scala, it is easy to both create new operations and compose new 
operations with existing operations.
</li></ul><h2 id="Some+sample+Arpeggeo+code">Some sample Arpeggeo code</h2><pre><code class="prettyprint lang-scala">  // create a new operation that multiplies each cell of 
  // each raster by a weight, and then add those two new
  // rasters together
  val op = Add(MultiplyConstant(raster1, weight1),
               MultiplyConstant(raster2, weight2))

  // create a new operation that takes the result of the
  // previous operation and divide each cell by the average 
  // weight, creating a weighted overlay of our two rasters
  val op2 = DivideConstant(op, (weight1 + weight2) / 2) 

  // or, we can use a simpler syntax:
  val avg = (weight1 + weight2) / 2 
  val wo  = (raster1 * weight1 + raster2 * weight2) / avg

  // To this point, we've only been composing new operations.
  // To run an operation:
  val server = Server(&quot;example&quot;)
  val result = server.run(wo)

</code></pre><h4>Contents</h4><div><a href="Arpeggeo.html">Arpeggeo</a></div><ol class="toc"> <li><div><a href="API+Reference.html">API Reference</a></div></li><li><div><a href="Operations.html">Operations</a></div></li><li><div><a href="Setting+up+Arpeggeo.html">Setting up Arpeggeo</a></div></li><li><div><a href="Using+the+template+project.html">Using the template project</a></div></li><li><div class="current">Creating Operations</div></li><li><div><a href="Parallel+and+Distributed+Calculation.html">Parallel and Distributed Calculation</a></div></li><li class="generated"><div><a href="Contents+in+Depth.html">Contents in Depth</a></div></li><li class="generated"><div><a href="Combined+Pages.html">Combined Pages</a></div></li> </ol>
          </div>
        </div>
        <a class="fork nav" href="http://github.com/azavea/trellis"><img alt="Fork me on GitHub" src="img/fork.png"></img></a>
      </body>
    </html>