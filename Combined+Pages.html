<html manifest="pamflet.manifest">
      <head>
        <title>Arpeggeo — Combined Pages</title>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/blueprint/screen.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/blueprint/grid.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/blueprint/print.css"></link> 
        <!--[if lt IE 8]>
          <link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection"/>
        <![endif]-->
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/pamflet.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/pamflet-print.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/pamflet-grid.css"></link>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/custom.css"></link>
        <script src="js/jquery-1.6.2.min.js"></script>
        <script src="js/pamflet.js"></script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"></link><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <meta charset="utf-8"></meta>
        <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      </head>
      <body>
        <a class="page prev nav" href="Contents+in+Depth.html">
            <span class="space">&nbsp;</span>
            <span class="flip">❧</span>
          </a>
        <div class="container">
          <div class="span-16 prepend-1 append-1">
            <div class="top nav span-16 title">
              <span>Arpeggeo</span>
               — Combined Pages
            </div>
          </div>
          <div class="span-16 prepend-1 append-1 contents">
            <h4>Contents</h4><div><a href="#Arpeggeo">Arpeggeo</a></div><ol class="toc"> <li><div><a href="#API+Reference">API Reference</a></div></li><li><div><a href="#Operations">Operations</a></div></li><li><div><a href="#Setting+up+Arpeggeo">Setting up Arpeggeo</a></div></li><li><div><a href="#Using+the+template+project">Using the template project</a></div></li><li><div><a href="#Creating+Operations">Creating Operations</a></div></li><li><div><a href="#Parallel+and+Distributed+Calculation">Parallel and Distributed Calculation</a></div></li> </ol><h1 id="Arpeggeo">Arpeggeo</h1><p><em>Arpeggeo</em> is a high performance geoprocessing engine and programming toolkit.  The goal of the project is to transform
user interaction with geospatial data by bringing the power of geospatial analysis to real time, interactive web applications.
</p><p>Arpeggeo was designed to solve three core problems, with a focus on raster processing:
</p><ul><li>Creating scalable, high performance geoprocessing web services
</li><li>Creating distributed geoprocessing services that can act on large data sets
</li><li>Parallelizing geoprocessing operations to take full advantage of multi-core architecture 
</li></ul><p>Arpeggeo is a project of Azavea (www.azavea.com), and was written by Josh Marcus (jmarcus@azavea.com) and Erik Osheim (eosheim@azavea.com).  Please contact us if you have any questions!
</p><h2 id="Features">Features</h2><ul><li>Arpeggeo is designed to help a developer create simple, standard REST services that return the results of geoprocessing models.
</li><li>Like an RDBS that can optimize queries, Arpeggeo will automatically parallelize and optimize your geoprocessing models where possible.  
</li><li>In the spirit of the object-functional style of Scala, it is easy to both create new operations and compose new 
operations with existing operations.
</li></ul><h2 id="Some+sample+Arpeggeo+code">Some sample Arpeggeo code</h2><pre><code class="prettyprint lang-scala">  // create a new operation that multiplies each cell of 
  // each raster by a weight, and then add those two new
  // rasters together
  val op = Add(MultiplyConstant(raster1, weight1),
               MultiplyConstant(raster2, weight2))

  // create a new operation that takes the result of the
  // previous operation and divide each cell by the average 
  // weight, creating a weighted overlay of our two rasters
  val op2 = DivideConstant(op, (weight1 + weight2) / 2) 

  // or, we can use a simpler syntax:
  val avg = (weight1 + weight2) / 2 
  val wo  = (raster1 * weight1 + raster2 * weight2) / avg

  // To this point, we've only been composing new operations.
  // To run an operation:
  val server = Server(&quot;example&quot;)
  val result = server.run(wo)

</code></pre><h2 id="API+Reference">API Reference</h2><h3 id="Scaladocs">Scaladocs</h3><p>You can find <em>Scaladocs</em> for the latest version of the project here:
</p><p><a  href="http://azavea.github.com/trellis/latest/api/index.html#trellis.package">http://azavea.github.com/trellis/latest/api/index.html#trellis.package</a>
</p><h3 id="Operations">Operations</h3><p>A full list of core operations can be in found in the Scala API documentation for the <code>trellis.operation</code> package: <a  href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.package">http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.package</a>.
</p><h3 id="Template+project">Template project</h3><p>We have created a template project that you can use as a launching pad for new REST
services based on Arpeggeo.  It is a simple project that uses SBT (Simple Build Tool)
to load the Arpeggeo dependencies and has the basic infrastructure in place to help
you get started quickly.  
<br/>
<a  href="https://github.com/azavea/trellis-template">https://github.com/azavea/trellis-template</a>
</p><h2 id="Operations">Operations</h2><table class="bordered-table zebra-striped">
      <thead>
          <tr>
            <th>Operation</th>
            <th>Output</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.Add">Add</a></code></td><td>Raster</td><td>Add the values of each cell in each raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.AddArray">AddArray</a></code></td><td>Raster</td><td>Add the values of each cell in each raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.AddConstant">AddConstant</a></code></td><td>Raster</td><td>Add a constant value to each cell.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.AutomaticNormalize">AutomaticNormalize</a></code></td><td>Raster</td><td>Normalize the values in the given raster so that all values are within the ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.BinaryDoCell">BinaryDoCell</a></code></td><td>Raster</td><td>Perform a function on every cell in a raster with the values from another raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.BinaryIfCell">BinaryIfCell</a></code></td><td>Raster</td><td>Given a condition over two rasters, set the value of each cell in the output ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.BinaryIfElseCell">BinaryIfElseCell</a></code></td><td>Raster</td><td>Given a condition over two rasters, set the value of each cell in the output ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.BinaryLocal">BinaryLocal</a></code></td><td>Raster</td><td>BinaryLocal is an abstract class for all operations that are both local (operating ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.Bitmask">Bitmask</a></code></td><td>Raster</td><td>Bitmask each cell by a constant value.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.BuildArrayHistogram">BuildArrayHistogram</a></code></td><td>Histogram</td><td>Build an array histogram (see <a name="trellis.stat.ArrayHistogram" class="extype" href="../stat/ArrayHistogram.html">ArrayHistogram</a> of values from ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.BuildCompressedArrayHistogram">BuildCompressedArrayHistogram</a></code></td><td>Histogram</td><td>Build a histogram (using the <a name="trellis.stat.CompressedArrayHistogram" class="extype" href="../stat/CompressedArrayHistogram.html">CompressedArrayHistogram</a> ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.BuildHistogram">BuildHistogram</a></code></td><td>Histogram</td><td>Generic trait used by the various histogram-building operations.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.BuildMapHistogram">BuildMapHistogram</a></code></td><td>Histogram</td><td>Build a histogram (using the <a name="trellis.stat.MapHistogram" class="extype" href="../stat/MapHistogram.html">MapHistogram</a> strategy) from ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.BuildRasterExtent">BuildRasterExtent</a></code></td><td>RasterExtent</td><td>Given a geographical extent and grid height/width, return an object used to ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.BurnPolygon">BurnPolygon</a></code></td><td>Raster</td><td>Rasterize a polygon and then draw it on the provided raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.BurnPolygons">BurnPolygons</a></code></td><td>Polygon</td><td>Rasterize an array of polygons and then draw them into the provided raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.BurnPolygonsWithTransform">BurnPolygonsWithTransform</a></code></td><td>Raster</td><td>Rasterize an array of polygons and then draw them into the provided raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.BurnPolygonsWithValue">BurnPolygonsWithValue</a></code></td><td>Polygon</td><td>Rasterize an array of polygons and then draw them into the provided raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.CachedOp">CachedOp</a></code></td><td>T</td><td>Trait providing caching support for operations which want to save their ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.ChunkRasterExtent">ChunkRasterExtent</a></code></td><td>RasterExtent</td><td>Used to chunk a RasterExtent object (geographical extent + grid information) ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.CopyRaster">CopyRaster</a></code></td><td>Raster</td><td>Given an operation producing a raster, returns a copy of this raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.CreateRaster">CreateRaster</a></code></td><td>Raster</td><td>Creates an empty raster object based on the given raster properties.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.CreateSimplePolygon">CreateSimplePolygon</a></code></td><td>Double)</td><td>Create a Polygon from an array of coordinates represented as a tuple (x,y).</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.CropRasterExtent">CropRasterExtent</a></code></td><td>RasterExtent</td><td>Given a geographical extent and grid height/width, return an object used to ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.CropRasterExtentByExtent">CropRasterExtentByExtent</a></code></td><td>RasterExtent</td><td>Given a geographical extent and grid height/width, return an object used to ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.CsvIntMap">CsvIntMap</a></code></td><td>Int</td><td>Create a Map of (String,String) =&gt; Int from a CSV file ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.Divide">Divide</a></code></td><td>Raster</td><td>Divide each value of one raster with the values from another raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.DivideConstant">DivideConstant</a></code></td><td>Raster</td><td>Divide each cell by a constant value.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.DivideConstantBy">DivideConstantBy</a></code></td><td>Raster</td><td>For each cell, divide a constant value by that cell's value.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.DoCell">DoCell</a></code></td><td>Raster</td><td>Perform a function on every cell in a raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.FindClassBreaks">FindClassBreaks</a></code></td><td>Int</td><td>Generate quantile class breaks for a given raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.FindColorBreaks">FindColorBreaks</a></code></td><td>ColorBreaks</td><td>Generate quantile class breaks with assigned colors.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.FindMinMax">FindMinMax</a></code></td><td>(Int,Int)</td><td>Find the minimum and maximum value of a raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.ForEach">ForEach</a></code></td><td>Z</td><td>Evaluates then given operation (op) to get an array of A's.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.ForEach2">ForEach2</a></code></td><td>Z</td><td>Evaluates then given operations (opA and opB) to get an array of A's and an ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.ForEach3">ForEach3</a></code></td><td>Z</td><td>Evaluates then given operations (opA opB, and opC) to get arrays of A's, B's ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.ForEachTile">ForEachTile</a></code></td><td>Raster</td><td>Perform an operation on every tile in a tileset, and return the new tileset.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.GenerateStatistics">GenerateStatistics</a></code></td><td>Statistics</td><td>Determine statistical data for the given histogram.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.GetPolygonExtent">GetPolygonExtent</a></code></td><td>Extent</td><td>Return the extent of a given polygon.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.GetRasterExtent">GetRasterExtent</a></code></td><td>RasterExtent</td><td>Get the trellis.geoattrs.RasterExtent from a given raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.Hillshade">Hillshade</a></code></td><td>Raster</td><td>Hillshade creates a raster that, visually, adds a three dimensional appearance to an elevation raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.Identity">Identity</a></code></td><td>Raster</td><td>Suspiciously similar to <a name="trellis.operation.CopyRaster" class="extype" href="CopyRaster.html">CopyRaster</a>, Identity returns ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.IfCell">IfCell</a></code></td><td>Raster</td><td>Maps all cells matching <code>cond</code> to <code>trueValue</code>.</p> ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.IfElseCell">IfElseCell</a></code></td><td>Raster</td><td>Set all values of output raster to one value or another based on whether a ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.InverseMask">InverseMask</a></code></td><td>Raster</td><td>Generate a raster with the values from the first raster, but only include ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.KernelDensity">KernelDensity</a></code></td><td>Raster</td><td>Compute the kernel density of a set of points onto a raster</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.Literal">Literal</a></code></td><td>A</td><td>Return the literal value specified.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.LoadFile">LoadFile</a></code></td><td>Raster</td><td>Load the raster data for a particular extent/resolution from the specified file.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.LoadRaster">LoadRaster</a></code></td><td>Raster</td><td>Load the raster data for a particular extent/resolution from the specified file.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.LoadRasterExtentFromFile">LoadRasterExtentFromFile</a></code></td><td>RasterExtent</td><td>Load the trellis.geoattrs.RasterExtent from the raster in the specified file.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.LocalOperation">LocalOperation</a></code></td><td>Raster</td><td>Local operations involve each individual value in a raster without information ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.Map1">Map1</a></code></td><td>Z</td><td>Map an Op[A] into an Op[Z] using a function from A =&gt; Z.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.Map2">Map2</a></code></td><td>Z</td><td>Map an Op[A] and Op[B] into an Op[Z] using a function from (A,B) =&gt; Z.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.Mask">Mask</a></code></td><td>Raster</td><td>Generate a raster with the values from the first raster, but only include ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.MaxConstant">MaxConstant</a></code></td><td>Raster</td><td>Set each cell to a constant number or the corresponding cell value, whichever is highest.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.MinConstant">MinConstant</a></code></td><td>Raster</td><td>Set each cell to a constant or its existing value, whichever is lowest.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.Multiply">Multiply</a></code></td><td>Raster</td><td>Multiply each cell of each raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.MultiplyArray">MultiplyArray</a></code></td><td>Raster</td><td>Multiply each cell of each raster in array.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.MultiplyConstant">MultiplyConstant</a></code></td><td>Raster</td><td>Multiply each cell by a constant.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.Negate">Negate</a></code></td><td>Raster</td><td>Negate (multiply by -1) each value in a raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.Operation">Operation</a></code></td><td>T</td><td>Base Operation for all Trellis functionality.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.PolygonExtent">PolygonExtent</a></code></td><td>Polygon</td><td>Return the extent of a given polygon.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.PolygonalZonalHistograms">PolygonalZonalHistograms</a></code></td><td>Histogram</td><td>Given a raster and an array of polygons, return a histogram summary of the cells ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.PowConstant">PowConstant</a></code></td><td>Raster</td><td>Raise each cell to the cth power.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.PrecomputedNormalize">PrecomputedNormalize</a></code></td><td>Raster</td><td>Normalize the values in the given raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.RenderPNG">RenderPNG</a></code></td><td>Byte</td><td>Generate a PNG from a given raster and a set of color breaks.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.ResampleRaster">ResampleRaster</a></code></td><td>Raster</td><td>This uses a nearest-neighbor algorithm to resample a raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.SplitMultiPolygon">SplitMultiPolygon</a></code></td><td>Polygon</td><td>Split multipolygon into polygons.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.StandardDeviation">StandardDeviation</a></code></td><td>Raster</td><td>Calculate the standard deviation of each cell from the values in the raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.Subtract">Subtract</a></code></td><td>Raster</td><td>Subtract each value in the second raster from the corresponding value in the first raster.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.SubtractConstant">SubtractConstant</a></code></td><td>Raster</td><td>Subtract a constant value from each cell.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.SubtractConstantBy">SubtractConstantBy</a></code></td><td>Raster</td><td>Subtract the value of each cell by a constant.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.UnaryLocal">UnaryLocal</a></code></td><td>Raster</td><td>Abstract class for all operations that are unary (operate on a single raster) and ...</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.WarpRaster">WarpRaster</a></code></td><td>Raster</td><td>Crop a raster to a given extent, using a nearest neighbor algorithm to resample.</td></tr>
<tr><td><code><a href="http://azavea.github.com/trellis/latest/api/index.html#trellis.operation.ZonalHistogram">ZonalHistogram</a></code></td><td>Histogram</td><td>Given a raster, return a histogram summary of the cells within each zone.</td></tr>
        </tbody>
      </table>
<h2 id="Setting+up+Arpeggeo">Setting up Arpeggeo</h2><h3 id="Configuration">Configuration</h3><p>Arpeggeo has two important configuration files, the application
configuration and the catalog, which defines what geospatial data
is available.
</p><h4 id="Application+configuration">Application configuration</h4><p>The main application configuration allows a variety of system parameters to be set.
The configuration file should be on the classpath of your application: e.g. if using
SBT, create the configuration file at src/main/resources/application.conf.
</p><p>You can also override individual configuration parameters with Java system properties, e.g.
<code>java -Dtrellis.port=5555 ...</code>
</p><p>Example:
</p><pre><code class="">trellis.host = &quot;0.0.0.0&quot; // IP address to which the server will listen
                         // (0.0.0.0 means listen to all ports)
trellis.port = 8888      // The server port 
trellis.rest-package = &quot;trellis.rest&quot; // The package that will be searched for
                                      // for rest services
trellis.tmp = &quot;/tmp&quot;     // A temporary directory to be used for scratch files
</code></pre><h4 id="Data+catalog">Data catalog</h4><p>The data catalog defines what data sources are available to your Arpeggeo server, and
can include metadata about the data in those sources.  Data catalogs are defined as JSON files.  Arpeggeo uses a custom format, ARG (Azavea Raster Grid), to store raster data.  ARG files have companion JSON configuration files which allows a data catalog to automatically
discover and load ARG files that are under a filesystem data directory configured in the
catalog.  For example, the following catalog.json file defines a data directory ”/var/arpeggeo/data” in which any .arg32 files with accompanying .json metadata will be loaded.
</p><pre><code class="prettyprint lang-json">{
 &quot;catalog&quot;: &quot;my-catalog&quot;,
 &quot;stores&quot;: [
  {
   &quot;store&quot;: &quot;data:fs&quot;,
   &quot;params&quot;: {
     &quot;type&quot;: &quot;fs&quot;,
     &quot;path&quot;: &quot;/var/arpeggeo/data&quot;
   }
  }
 ]
}
</code></pre><h3 id="Importing+Raster+Data">Importing Raster Data</h3><p>There is a script in the /scripts directory that you can use to convert raster data in
GeoTiff format to the ARG32 format.  It assumes that you are using a Unix shell (Linux/Mac) and have installed “wget”.
</p><p>For example, to convert <code>`your_geotiff.tif</code><code> to </code><code>output.arg32</code>`, change to the
directory you’ve checked out the template and run:
</p><pre><code class="prettyprint lang-bash">scripts/trellis_import_geotiff your_geotiff.tif output.arg32
</code></pre><p>The first time you run the script it will download the necessary Trellis libraries to your
system.
</p><h2 id="Using+the+template+project">Using the template project</h2><p>We have provided a sample project that provides a template for creating a 
geoprocessing web service with Arpeggeo.  It is a blank 
slate for your own 
development that provides a development environment that is set up
with the necessary dependencies in place, making it a little easier to get started.  
<br/>
The project loads Arpeggeo as a
library, includes some basic configuration, and has a very simple “hello world” 
web service in place for you 
to edit.
</p><p>If you are a first time user, you may want to use the template along with the tutorial
included in this documentation to start exploring how to build your own geoprocessing service.  If you’re new to Scala, you’ll need to choose a text editor for editing Scala, but
you won’t need to install Scala or any other files to get started.  The following 
instructions assume you are running under Linux or OS X.
</p><h2 id="Step+1%3A+Run+SBT">Step 1: Run SBT</h2><p>This project uses SBT, Simple Build Tool, for compilation and execution.
</p><p>If you don’t have SBT installed already, you can run a script in the template
directory (from https://github.com/paulp/sbt-extras) that will automatically download it for you.
</p><p>At the command line, go to the directory where you’ve installed this template
and run ”./sbt”.  For example:
</p><pre><code class="prettyprint lang-bash">git clone xxxx
cd arpegeo-template
./sbt
</code></pre><p>The first time you run SBT, there will be a significant delay as all of the
necessary libraries are downloaded.
</p><p>If you get any sort of error that a library can’t be downloaded, please let us 
know so we can fix the problem.  SBT downloads the libraries from where they
are hosted on the internet, so problems can arise when repositories change.  
<br/>
When sbt is done loading and compiling, you’ll see an sbt prompt:
</p><pre><code class="prettyprint lang-"> &gt;
</code></pre><p>If you type <code>`run</code><code>, you'll see some messages from Jetty, the embedded webserver that responds to Arpeggeo requests. 
</code><code>
 &gt; run
[info] Starting server on port 8888.
[error] 2012-02-06 14:17:08.255:INFO:oejs.Server:jetty-8.1.0.RC4
[error] 2012-02-06 14:17:08.329:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:8888 STARTING
</code>`
</p><p>This means that you are now running a webserver on port 8888 that responds to
requests.  Go to 
</p><p>http://localhost:8888/template
</p><p>to see the template web service, which just shows HTML of “Hello Trellis!”
</p><h2 id="Step+2%3A+Edit+the+configuration+file">Step 2: Edit the configuration file</h2><p>There’s a configuration file you can edit at src/main/resources/application.conf.  For example, some settings include:
</p><p>What ip address should the server be listening to?
</p><pre><code class="">trellis.host = &quot;0.0.0.0&quot; // IP address to which the server will listen
                         // (0.0.0.0 means listen to all ports)
trellis.port = 8888      // The server port 
trellis.rest-package = &quot;trellis.rest&quot; // The package that will be searched for
                                      // for rest services
trellis.tmp = &quot;/tmp&quot;     // A temporary directory to be used for scratch files
</code></pre><h2 id="Step+3%3A+Import+data">Step 3: Import data</h2><p>There is a script in the /scripts directory that you can use to convert raster data in
GeoTiff format to the ARG32 format.  It assumes that you are using a Unix shell (Linux/Mac) and have installed “wget”.
</p><p>For example, to convert <code>`your_geotiff.tif</code><code> to </code><code>output.arg32</code>`, change to the
directory you’ve checked out the template and run:
</p><pre><code class="prettyprint lang-bash">scripts/trellis_import_geotiff your_geotiff.tif output.arg32
</code></pre><p>The first time you run the script it will download the necessary Trellis libraries to your
system.
</p><h2 id="Step+4%3A+Edit+the+catalog.json+file">Step 4: Edit the catalog.json file</h2><p>The catalog.json file (in src/main/resources) defines the data sources that are
available to the Arpeggeo service.  You can move it to an alternate location if you
define the file path in the configuration file.
</p><h2 id="Step+5%3A+Create+your+service%21">Step 5: Create your service!</h2><p>The blank REST service is in the file src/main/scala/trellis/rest/TemplateResource.scala.  Edit that file to change the existing service, or create a similar 
class in the “trellis.rest” package to create a new service.
</p><p>If you are using the ScalaIDE for Eclipse (http://scala-ide.org/), you should
type <code>`eclipse</code>` at the sbt prompt, and then import the project into Eclipse.
(If you are using emacs, you should consider using ENSIME: https://github.com/aemoncannon/ensime.)  
</p><h2 id="Additional+notes">Additional notes</h2><h3 id="Triggered+Restart">Triggered Restart</h3><p>Note: If you run … 
</p><p> &gt; ~re-start
</p><p>… at the sbt prompt, you will be in a ‘triggered restart’ mode.  As soon
as you edit your source files, the application will re-compile and restart 
with your updated code. 
</p><h2 id="Creating+Operations">Creating Operations</h2><p>Ideally, a new geoprocessing service can be composed with existing operations that
have already been created for you.  The tutorial, for example, shows a series of
examples of a service being created by composing existing operations.  But sometimes
it is necessary to create new operations instead of simply composing a new process with
existing operations.  There is a simple and an advanced structure for creating new operations.
</p><h3 id="Simple">Simple</h3><h3 id="Advanced">Advanced</h3><h4 id="Parallel+and+Distributed+Calculation">Parallel and Distributed Calculation</h4><p>While it’s not necessary to understand why we follow the pattern above, here is a quick 
explanation if you’re curious.  Behind the scenes, Arpeggeo is using the actor model for parallel and distributed computation, which means that the primary abstraction is message passing instead of shared memory.  This event-based model allows us to re-use the same threads by interleaving calculations for different processes on the same threads, but this means that nothing can ever block or stop on a thread while waiting for another result because that would hold up the other work that is scheduled to execute on the same thread.  By using the continuation passing style from functional programming (http://en.wikipedia.org/wiki/Continuation-passing_style) we can perform work in a series of stages, in which requests
are first sent out for calculations to be processed and then when all of the results
are received, we can execute the next step of the calculation, without ever blocking
execution on an individual thread.
</p><h2 id="Running+operations">Running operations</h2><h3 id="Parallel+execution">Parallel execution</h3><h3 id="Distributed+execution">Distributed execution</h3><ul><li>When an operation is 
</li></ul><p><em>Arpeggeo</em> is a high performance geoprocessing engine and programming toolkit.  The goal of the project is to transform
user interaction with geospatial data by bringing the power of geospatial analysis to real time, interactive web applications.
</p><p>Arpeggeo was designed to solve three core problems, with a focus on raster processing:
</p><ul><li>Creating scalable, high performance geoprocessing web services
</li><li>Creating distributed geoprocessing services that can act on large data sets
</li><li>Parallelizing geoprocessing operations to take full advantage of multi-core architecture 
</li></ul><p>Arpeggeo is a project of Azavea (www.azavea.com), and was written by Josh Marcus (jmarcus@azavea.com) and Erik Osheim (eosheim@azavea.com).  Please contact us if you have any questions!
</p><h2 id="Features">Features</h2><ul><li>Arpeggeo is designed to help a developer create simple, standard REST services that return the results of geoprocessing models.
</li><li>Like an RDBS that can optimize queries, Arpeggeo will automatically parallelize and optimize your geoprocessing models where possible.  
</li><li>In the spirit of the object-functional style of Scala, it is easy to both create new operations and compose new 
operations with existing operations.
</li></ul><h2 id="Some+sample+Arpeggeo+code">Some sample Arpeggeo code</h2><pre><code class="prettyprint lang-scala">  // create a new operation that multiplies each cell of 
  // each raster by a weight, and then add those two new
  // rasters together
  val op = Add(MultiplyConstant(raster1, weight1),
               MultiplyConstant(raster2, weight2))

  // create a new operation that takes the result of the
  // previous operation and divide each cell by the average 
  // weight, creating a weighted overlay of our two rasters
  val op2 = DivideConstant(op, (weight1 + weight2) / 2) 

  // or, we can use a simpler syntax:
  val avg = (weight1 + weight2) / 2 
  val wo  = (raster1 * weight1 + raster2 * weight2) / avg

  // To this point, we've only been composing new operations.
  // To run an operation:
  val server = Server(&quot;example&quot;)
  val result = server.run(wo)

</code></pre><h2 id="Parallel+and+Distributed+Calculation">Parallel and Distributed Calculation</h2><h3 id="Parallel+Execution">Parallel Execution</h3><p>Most operations have “child operations” which are the inputs or incoming data streams
that the operation acts on.  Arpeggeo will automatically run all child operations in
parallel.  For example, if you are adding each cell of five rasters together, the
service will calculate each input raster in parallel (if resources allow).  If working
with a single large data set (e.g. a large raster), it is usually beneficial to transform
the raster into a <code>TiledRaster</code> which allows the system to parallelize the work. 
</p><h3 id="Distributed+Execution">Distributed Execution</h3><p>With a single command, an operation can be transformed into a RemoteOperation that
sends each of its child operations to a remote Arpeggeo server for execution.  
</p><pre><code class="prettyprint lang-scala">Add(r1,r2,r3).remote(cluster) // calculate input rasters on remote cluster
</code></pre><p>The remote cluster or server is an Akka actor or load balancer, defined using the Akka 
library configuration.  See the Akka documenation for more information.  (http://akka.io/docs/akka/2.0-M4/)
</p><p>For operations that do not need to pass data over the network, the overhead can be as 
low as a few milliseconds.  When passing raster data, the time overhead depends on the
network and the size of the rasters, but an operation that sends and receives a 256x256 raster tile can be executed in under 15ms, 512x512 in ~30ms, etc.
</p><h3 id="Architecture">Architecture</h3><p>Behind the scenes, Arpeggeo is using the actor model for parallel and distributed computation, which means that the primary abstraction is message passing instead of shared memory.  This event-based model allows us to re-use the same threads by interleaving calculations for different processes on the same threads, but this means that nothing can ever block or stop on a thread while waiting for another result because that would hold up the other work that is scheduled to execute on the same thread.  By using the continuation passing style from functional programming (http://en.wikipedia.org/wiki/Continuation-passing_style) we can perform work in a series of stages, in which requests
are first sent out for calculations to be processed and then when all of the results
are received, we can execute the next step of the calculation, without ever blocking
execution on an individual thread.  Operations are sent as immutable messages, and should
be referrentially transparent, which allows us to perform optimizations such as combining
local raster operations. 
</p>
          </div>
        </div>
        <a class="fork nav" href="http://github.com/azavea/trellis"><img alt="Fork me on GitHub" src="img/fork.png"></img></a>
      </body>
    </html>